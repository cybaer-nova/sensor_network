{"config":{"lang":["en","pt"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sensor Network","text":"<p>This repository holds the Sensor Network code stack for a LoRa based wireless sensor network. It contains the packages needed for deploying and monitoring a network with a gateway and node devices. </p> <p> </p>"},{"location":"#introduction","title":"Introduction","text":"<p>The Sensor Network repository consists on a set of software that allows for a wireless sensor network to be deployed using the LoRa modulation technology. To this purpose, the repository includes Arduino packages for the node devices and gateway device.</p> <p>Additionally a python application with a GUI to monitor and manage the network is included. This application is also used to connect the network to the ROS middleware so as to provide integration with vehicles like UAVs and AGVs.</p> <p>The figure below depicts the network architecture used.</p> <p></p>"},{"location":"Gateway/Classes/","title":"Classes","text":"<ul> <li>struct strMsg Data structure that holds the encrypted payload along with other important fields. </li> <li>struct strPayload Data structure that holds the data for all the fields in the payload. </li> </ul> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Classes/structstr_msg/","title":"strMsg","text":"<p>Data structure that holds the encrypted payload along with other important fields. </p> <p><code>#include &lt;comms_protocol.h&gt;</code></p>"},{"location":"Gateway/Classes/structstr_msg/#public-attributes","title":"Public Attributes","text":"Name byte msg byte msgID char flag byte nodeID byte actID byte actVal"},{"location":"Gateway/Classes/structstr_msg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Gateway/Classes/structstr_msg/#variable-msg","title":"variable msg","text":"<pre><code>byte msg;\n</code></pre>"},{"location":"Gateway/Classes/structstr_msg/#variable-msgid","title":"variable msgID","text":"<pre><code>byte msgID;\n</code></pre>"},{"location":"Gateway/Classes/structstr_msg/#variable-flag","title":"variable flag","text":"<pre><code>char flag;\n</code></pre>"},{"location":"Gateway/Classes/structstr_msg/#variable-nodeid","title":"variable nodeID","text":"<pre><code>byte nodeID;\n</code></pre>"},{"location":"Gateway/Classes/structstr_msg/#variable-actid","title":"variable actID","text":"<pre><code>byte actID;\n</code></pre>"},{"location":"Gateway/Classes/structstr_msg/#variable-actval","title":"variable actVal","text":"<pre><code>byte actVal;\n</code></pre> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Classes/structstr_payload/","title":"strPayload","text":"<p>Data structure that holds the data for all the fields in the payload. </p> <p><code>#include &lt;comms_protocol.h&gt;</code></p>"},{"location":"Gateway/Classes/structstr_payload/#public-attributes","title":"Public Attributes","text":"Name byte nodeID byte sensorID byte sensorVal byte msgID char flag int RSSI float SNR float VBAT double milis"},{"location":"Gateway/Classes/structstr_payload/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Gateway/Classes/structstr_payload/#variable-nodeid","title":"variable nodeID","text":"<pre><code>byte nodeID;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-sensorid","title":"variable sensorID","text":"<pre><code>byte sensorID;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-sensorval","title":"variable sensorVal","text":"<pre><code>byte sensorVal;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-msgid","title":"variable msgID","text":"<pre><code>byte msgID;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-flag","title":"variable flag","text":"<pre><code>char flag;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-rssi","title":"variable RSSI","text":"<pre><code>int RSSI;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-snr","title":"variable SNR","text":"<pre><code>float SNR;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-vbat","title":"variable VBAT","text":"<pre><code>float VBAT;\n</code></pre>"},{"location":"Gateway/Classes/structstr_payload/#variable-milis","title":"variable milis","text":"<pre><code>double milis;\n</code></pre> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Examples/","title":"Examples","text":"<p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Files/","title":"Files","text":"<ul> <li>file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. </li> <li>file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. </li> <li>file gateway_serial.ino Gateway script - send sensor data to gateway and receive commands from gateway. </li> <li>file gateway_serial_definitions.h </li> </ul> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Files/comms__protocol_8cpp/","title":"comms_protocol.cpp","text":"<p>Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios.  More...</p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#functions","title":"Functions","text":"Name cppQueue relay_q(sizeof(char) * MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE , IMPLEMENTATION ) cppQueue msg_q(sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode()Sets the LoRa radio to receive mode. void LoRa_txMode()Sets the LoRa radio to transmit mode. void LoRa_sendMessage(byte * message, byte nodeID)Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * encrypt(char msg[MAX_PAYLOAD_SIZE])Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg(char msg[MAX_PAYLOAD_SIZE+1])Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin(int a, int b)returns the minimum value between two integers void sendAck(byte msgID, byte nodeID)Send an acknowledge message confirming the reception of an uplink transmission. void sendStatusRequest(byte nodeID)Send a status request message asking for a specific node to respond with a status update. void sendActuatorControl(byte nodeID, byte actID, byte actVal)Send a control message to set a value for a node's actuator. void getMsgFromQueueAndSend(unsigned long currentMillis)Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void relayMsgFromQueueToServer(unsigned long currentMillis)Get a message from the relay queue and send it to the server via serial communication. void constructJsonAndAddToQueue(Payload p)Builds a json string containg the message information and adds the string to the relay queue. void relayDownlinkMsg(char * dlMsg)Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. void onReceive(int packetSize)Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server."},{"location":"Gateway/Files/comms__protocol_8cpp/#attributes","title":"Attributes","text":"Name int currMsg int count unsigned long prevMilR unsigned long prevMil int msgCount aes256_context ctxt"},{"location":"Gateway/Files/comms__protocol_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Gateway/Files/comms__protocol_8cpp/#function-relay_q","title":"function relay_q","text":"<pre><code>cppQueue relay_q(\n    sizeof(char) * MAX_JSON_PAYLOAD_SIZE,\n    MAX_R_QUEUE_SIZE ,\n    IMPLEMENTATION \n)\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-msg_q","title":"function msg_q","text":"<pre><code>cppQueue msg_q(\n    sizeof(Msg) ,\n    MAX_QUEUE_SIZE ,\n    IMPLEMENTATION \n)\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_rxmode","title":"function LoRa_rxMode","text":"<pre><code>void LoRa_rxMode()\n</code></pre> <p>Sets the LoRa radio to receive mode. </p> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_txmode","title":"function LoRa_txMode","text":"<pre><code>void LoRa_txMode()\n</code></pre> <p>Sets the LoRa radio to transmit mode. </p> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-lora_sendmessage","title":"function LoRa_sendMessage","text":"<pre><code>void LoRa_sendMessage(\n    byte * message,\n    byte nodeID\n)\n</code></pre> <p>Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. </p> <p>Parameters: </p> <ul> <li>message message to send </li> <li>nodeID ID of the destination node </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-encrypt","title":"function encrypt","text":"<pre><code>byte * encrypt(\n    char msg[MAX_PAYLOAD_SIZE]\n)\n</code></pre> <p>Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. </p> <p>Parameters: </p> <ul> <li>msg message array to be decrypted </li> </ul> <p>Return: byte* a byte array containing the encrypted message </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-decryptmsg","title":"function decryptMsg","text":"<pre><code>char * decryptMsg(\n    char msg[MAX_PAYLOAD_SIZE+1]\n)\n</code></pre> <p>Decrypts a message string using the AES256 algorythm with the corresponding node key. </p> <p>Parameters: </p> <ul> <li>msg message string to be decrypted </li> </ul> <p>Return: char* an array of characters containing the decrypted message </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-mymin","title":"function mymin","text":"<pre><code>int mymin(\n    int a,\n    int b\n)\n</code></pre> <p>returns the minimum value between two integers </p> <p>Parameters: </p> <ul> <li>a first integer to compare </li> <li>b second integer to compare </li> </ul> <p>Return: int the smaller between a and b </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendack","title":"function sendAck","text":"<pre><code>void sendAck(\n    byte msgID,\n    byte nodeID\n)\n</code></pre> <p>Send an acknowledge message confirming the reception of an uplink transmission. </p> <p>Parameters: </p> <ul> <li>msgID ID of the message being acknowledged </li> <li>nodeID ID of the destination node </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendstatusrequest","title":"function sendStatusRequest","text":"<pre><code>void sendStatusRequest(\n    byte nodeID\n)\n</code></pre> <p>Send a status request message asking for a specific node to respond with a status update. </p> <p>Parameters: </p> <ul> <li>nodeID ID of the destination node </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-sendactuatorcontrol","title":"function sendActuatorControl","text":"<pre><code>void sendActuatorControl(\n    byte nodeID,\n    byte actID,\n    byte actVal\n)\n</code></pre> <p>Send a control message to set a value for a node's actuator. </p> <p>Parameters: </p> <ul> <li>nodeID ID of the destination node </li> <li>actID ID of the actuator to control </li> <li>actVal Value to set the actuator to </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-getmsgfromqueueandsend","title":"function getMsgFromQueueAndSend","text":"<pre><code>void getMsgFromQueueAndSend(\n    unsigned long currentMillis\n)\n</code></pre> <p>Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. </p> <p>Parameters: </p> <ul> <li>currentMillis current time in millisenconds since boot </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-relaymsgfromqueuetoserver","title":"function relayMsgFromQueueToServer","text":"<pre><code>void relayMsgFromQueueToServer(\n    unsigned long currentMillis\n)\n</code></pre> <p>Get a message from the relay queue and send it to the server via serial communication. </p> <p>Parameters: </p> <ul> <li>currentMillis current time in millisenconds since boot </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-constructjsonandaddtoqueue","title":"function constructJsonAndAddToQueue","text":"<pre><code>void constructJsonAndAddToQueue(\n    Payload p\n)\n</code></pre> <p>Builds a json string containg the message information and adds the string to the relay queue. </p> <p>Parameters: </p> <ul> <li>p payload structure containing the message information along with RSSI, SNR and battery voltage </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-relaydownlinkmsg","title":"function relayDownlinkMsg","text":"<pre><code>void relayDownlinkMsg(\n    char * dlMsg\n)\n</code></pre> <p>Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. </p> <p>Parameters: </p> <ul> <li>dlMsg character array containing the downlink message to be relayed </li> </ul>"},{"location":"Gateway/Files/comms__protocol_8cpp/#function-onreceive","title":"function onReceive","text":"<pre><code>void onReceive(\n    int packetSize\n)\n</code></pre> <p>Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. </p> <p>Parameters: </p> <ul> <li>packetSize size of the incoming message in bytes </li> </ul>"},{"location":"Gateway/Files/comms__protocol_8cpp/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-currmsg","title":"variable currMsg","text":"<pre><code>int currMsg = -1;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-count","title":"variable count","text":"<pre><code>int count = 0;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-prevmilr","title":"variable prevMilR","text":"<pre><code>unsigned long prevMilR;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-prevmil","title":"variable prevMil","text":"<pre><code>unsigned long prevMil;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-msgcount","title":"variable msgCount","text":"<pre><code>int msgCount = 0;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#variable-ctxt","title":"variable ctxt","text":"<pre><code>aes256_context ctxt;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8cpp/#source-code","title":"Source code","text":"<pre><code>\n#include \"comms_protocol.h\"\n\nint currMsg = -1;\nint count = 0;\nunsigned long prevMilR;\nunsigned long prevMil;\nint msgCount = 0;\n\ncppQueue  relay_q(sizeof(char)*MAX_JSON_PAYLOAD_SIZE, MAX_R_QUEUE_SIZE, IMPLEMENTATION);\ncppQueue  msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION);\naes256_context ctxt;\n\n\nvoid LoRa_rxMode() {\n  LoRa.disableInvertIQ();\n  LoRa.receive();\n}\n\nvoid LoRa_txMode() {\n  LoRa.idle();                          // set standby mode\n  LoRa.enableInvertIQ();                // active invert I and Q signals\n}\n\nvoid LoRa_sendMessage(byte *message, byte nodeID) {\n  LoRa_txMode();\n  LoRa.beginPacket();\n  LoRa.write(netID);\n  LoRa.write(nodeID);\n  LoRa.write(message, MAX_ENC_PAYLOAD_SIZE);\n  LoRa.endPacket(false);\n  LoRa_rxMode();\n}\n\nbyte *encrypt(char msg[MAX_PAYLOAD_SIZE]) {\n  String enc = \"\";\n  const char * p = msg;\n  static byte plain [BLOCK_SIZE];\n  memset (plain, 0, BLOCK_SIZE);  // ensure trailing zeros\n  memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE));\n  aes256_encrypt_ecb(&amp;ctxt, plain);\n  return plain;\n}\n\nchar  *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]) {\n  static char data[MAX_PAYLOAD_SIZE+1];\n  memcpy(data, msg, MAX_PAYLOAD_SIZE+1);\n  aes256_decrypt_ecb(&amp;ctxt, (uint8_t *)data);\n  return (char *)data;\n}\n\nint mymin(int a, int b){\n  if (a&gt;b)\n    return b;\n  return a;\n}\n\nvoid sendAck(byte msgID, byte nodeID) {\n  String enc;\n  char payload[MAX_PAYLOAD_SIZE];\n  byte l = MAX_PAYLOAD_SIZE;\n  Msg msg;\n\n  sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48);\n\n  aes256_init(&amp;ctxt, keys[(int)nodeID]);\n\n  byte *plain = encrypt(payload);\n  memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE);\n  msg.msg[MAX_PAYLOAD_SIZE] = '\\0';\n\n  aes256_done(&amp;ctxt);\n\n  msg.msgID = msgID;\n  msg.flag = 'a';\n  msg.nodeID = nodeID;\n  msg_q.push(&amp;msg);\n}\n\nvoid sendStatusRequest(byte nodeID) {\n  Msg msg;\n  String enc;\n\n  char payload[MAX_PAYLOAD_SIZE];\n  msgCount ++;\n  if (msgCount == 0)\n    msgCount ++;\n  msg.msgID = (byte) msgCount;\n  msg.flag = 's';\n  msg.nodeID = nodeID;\n  byte l = (byte) MAX_PAYLOAD_SIZE;\n\n  sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 's', (char)48, (char)48);\n\n  if (nodeID == BROADCAST_ID)\n    aes256_init(&amp;ctxt, keys[0]);\n  else\n    aes256_init(&amp;ctxt, keys[(int)nodeID]);\n\n  byte *plain = encrypt(payload);\n  memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE);\n  msg.msg[MAX_PAYLOAD_SIZE] = '\\0';\n\n  aes256_done(&amp;ctxt);\n\n  if (!msg_q.push(&amp;msg)){\n    char msgText[MAX_JSON_PAYLOAD_SIZE];\n    sprintf(msgText, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"status\\\":\\\"%d\\\"}\", millis(), msg.msgID, 'd', msg.nodeID, 0);\n    relay_q.push(&amp;msgText);\n  }\n}\n\nvoid sendActuatorControl(byte nodeID, byte actID, byte actVal) {\n  Msg msg;\n  String enc;\n  char payload[MAX_PAYLOAD_SIZE];\n  msgCount ++;\n  if (msgCount == 0)\n    msgCount ++;\n  msg.msgID = (byte) msgCount;\n  msg.actID = actID;\n  msg.actVal = actVal;\n  msg.flag = 'c';\n  msg.nodeID = nodeID;\n  byte l = (byte)MAX_PAYLOAD_SIZE;\n\n  sprintf(payload, \"%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'c', (char)actID, (char)actVal);\n\n  aes256_init(&amp;ctxt, keys[(int)nodeID]);\n\n  byte *plain = encrypt(payload);\n  memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE);\n  msg.msg[MAX_PAYLOAD_SIZE] = '\\0';\n\n  aes256_done(&amp;ctxt);\n\n  // Add msg to msg queue\n  msg_q.push(&amp;msg);\n}\n\nvoid getMsgFromQueueAndSend(unsigned long currentMillis) {\n  if (!msg_q.isEmpty()) {\n\n    // START print msg queue\n    /*Msg test;\n    for(int i=0; i&lt;msg_q.getCount(); i++){\n      msg_q.peekIdx(&amp;test, i);\n      Serial.print(test.msgID);\n      Serial.print(\", \");\n    }\n    Serial.println(msg_q.getCount());*/\n    // END print msg queue\n\n\n    Msg msg;\n    msg_q.peek(&amp;msg);\n\n    if (currMsg == msg.msgID)\n      count ++;\n    else\n      count = 0;\n\n    currMsg = msg.msgID;\n    if (count &lt; MAX_N_RETRY) {\n      Payload p;\n      p.msgID = msg.msgID;\n      p.flag = 'd';\n      p.nodeID = msg.nodeID;\n      p.sensorID = 1; // Using sensorID as status\n      constructJsonAndAddToQueue(p);\n\n      LoRa_sendMessage(msg.msg, msg.nodeID);\n\n      if(msg.flag == 'a')\n        msg_q.drop();\n      prevMil = currentMillis;\n    } else {\n      if (msg.flag == 's' || msg.flag == 'c') {\n        Payload p;\n        p.msgID = msg.msgID;\n        p.flag = 'f';\n        p.nodeID = msg.nodeID;\n        constructJsonAndAddToQueue(p);\n      }\n      msg_q.drop();\n    }\n  } else {\n    prevMil = currentMillis;\n  }\n}\n\n void relayMsgFromQueueToServer(unsigned long currentMillis) {\n  if (!relay_q.isEmpty()) {\n\n    char msg[MAX_JSON_PAYLOAD_SIZE];\n    relay_q.pop(&amp;msg);\n    int i;\n    for(i=0; i&lt;MAX_JSON_PAYLOAD_SIZE; i++)\n      if (msg[i] == '\\0')\n        break;\n\n\n    Serial.write(\"rm\");\n    Serial.write(msg, i);\n    Serial.write(\"\\n\");\n  }\n  prevMilR = currentMillis;\n}\n\n void constructJsonAndAddToQueue(Payload p) {\n  char msg[MAX_JSON_PAYLOAD_SIZE];\n\n  switch (p.flag) {\n    case 'u':\n      sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"sID\\\":\\\"%d\\\",\\\"sVal\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, (p.sensorID - 1), (p.sensorVal - 1), p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10);\n      break;\n    case 's':\n      sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"state\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, 1, p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10);\n      break;\n    case 'a':\n      sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"actID\\\":\\\"%d\\\",\\\"actVal\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"%d\\\",\\\"SNR\\\":\\\"%d.%02d\\\",\\\"VBAT\\\":\\\"%d.%01d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, (p.sensorID - 1), (p.sensorVal - 1), p.RSSI, (int)p.SNR, (int)(p.SNR * 100) % 100, (int)p.VBAT, (int)(p.VBAT * 10) % 10);\n      break;\n    case 'f':\n      sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"state\\\":\\\"%d\\\",\\\"RSSI\\\":\\\"0\\\",\\\"SNR\\\":\\\"0\\\",\\\"VBAT\\\":\\\"0\\\"}\", millis(), p.msgID, 's', p.nodeID, 0);\n      break;\n    case 'd':\n      sprintf(msg, \"{\\\"t\\\":\\\"%lu\\\",\\\"msgID\\\":\\\"%d\\\",\\\"f\\\":\\\"%c\\\",\\\"nID\\\":\\\"%d\\\",\\\"status\\\":\\\"%d\\\"}\", millis(), p.msgID, p.flag, p.nodeID, p.sensorID);\n      break;\n  }\n  relay_q.push(&amp;msg);\n}\n\nvoid relayDownlinkMsg(char *dlMsg) {\n  char flag = dlMsg[0];\n  int nodeID;\n\n  switch (flag) {\n    case 's':\n      sscanf(dlMsg, \"%*c,%d\", &amp;nodeID);\n      if(nodeID == -1)\n        sendStatusRequest((byte)BROADCAST_ID);\n      else\n        sendStatusRequest((byte)nodeID);\n      break;\n    case 'c':\n      int actID;\n      int actVal;\n      sscanf(dlMsg, \"%*c,%d,%d,%d\", &amp;nodeID, &amp;actID, &amp;actVal);\n      sendActuatorControl((byte)nodeID, (byte)(actID + 1), (byte)(actVal + 1));\n      break;\n    case 'p':\n      int sf;\n      long sb;\n      int crd;\n      sscanf(dlMsg, \"%*c,%d,%ld,%d\", &amp;crd, &amp;sb, &amp;sf);\n      LoRa.setSignalBandwidth(sb);\n      LoRa.setCodingRate4(crd);\n      LoRa.setSpreadingFactor(sf);\n      break;\n  }\n}\n\nvoid onReceive(int packetSize) {\n  byte rNetID = LoRa.read();\n  byte rnID = LoRa.read();\n  char buffer1[MAX_ENC_PAYLOAD_SIZE];\n  String message = \"\";\n  int i=0;\n  while (LoRa.available()) {\n    buffer1[i] = (char)LoRa.read();\n    i++;\n  }\n\n  if (rNetID = netID) {\n    byte len;\n    Payload p;\n\n    aes256_init(&amp;ctxt, keys[(int)rnID]);\n    strcpy(buffer1, decryptMsg(buffer1));\n    aes256_done(&amp;ctxt);\n\n    buffer1[8] = '\\0';\n\n    //Serial.println(buffer1);\n    char a,b;\n    //Serial.println(buffer1);\n    if(sscanf(buffer1, \"%c%c%c%c%c%c%c%c\", &amp;p.nodeID, &amp;p.msgID, &amp;len, &amp;p.flag, &amp;p.sensorID, &amp;p.sensorVal, &amp;a, &amp;b) == 8){\n      p.VBAT = (int)(a-1) + (int)(b-1) * 0.1;\n      //Serial.println(p.VBAT);\n      Msg msg;\n      p.RSSI = LoRa.packetRssi();\n      p.SNR = LoRa.packetSnr();\n      if (p.flag == 'u') {\n        sendAck(p.msgID, p.nodeID);\n        //p.sensorVal = buffer1[14];\n      }\n      if (p.flag == 's') {\n        //sendAck(p.msgID, p.nodeID);\n        msg_q.peek(&amp;msg);\n        if (p.msgID == msg.msgID) {\n          msg_q.drop();\n        }\n      } else if (p.flag == 'a') {\n        msg_q.peek(&amp;msg);\n        if (p.msgID == msg.msgID) {\n          p.sensorID = msg.actID;\n          p.sensorVal = msg.actVal;\n          msg_q.drop();\n        }\n      }\n      constructJsonAndAddToQueue(p);\n    }\n  }\n}\n</code></pre> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Files/comms__protocol_8h/","title":"comms_protocol.h","text":"<p>Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library.  More...</p>"},{"location":"Gateway/Files/comms__protocol_8h/#classes","title":"Classes","text":"Name struct strPayload Data structure that holds the data for all the fields in the payload. struct strMsg Data structure that holds the encrypted payload along with other important fields."},{"location":"Gateway/Files/comms__protocol_8h/#types","title":"Types","text":"Name typedef struct strPayload Payload Data structure that holds the data for all the fields in the payload. typedef struct strMsg Msg Data structure that holds the encrypted payload along with other important fields."},{"location":"Gateway/Files/comms__protocol_8h/#functions","title":"Functions","text":"Name void LoRa_rxMode()Sets the LoRa radio to receive mode. void LoRa_txMode()Sets the LoRa radio to transmit mode. void LoRa_sendMessage(byte * message, byte nodeID)Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. int mymin(int a, int b)returns the minimum value between two integers char * decryptMsg(char msg[MAX_PAYLOAD_SIZE+1])Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive(int packetSize)Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. void onTxDone() byte * encrypt(char msg[MAX_PAYLOAD_SIZE])Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. void sendAck(byte msgID, byte nodeID)Send an acknowledge message confirming the reception of an uplink transmission. void relayMsgFromQueueToServer(unsigned long currentMillis)Get a message from the relay queue and send it to the server via serial communication. void constructJsonAndAddToQueue(Payload p)Builds a json string containg the message information and adds the string to the relay queue. void relayDownlinkMsg(char * dlMsg)Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. void getMsgFromQueueAndSend(unsigned long currentMillis)Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatusRequest(byte nodeID)Send a status request message asking for a specific node to respond with a status update. void sendActuatorControl(byte nodeID, byte actID, byte actVal)Send a control message to set a value for a node's actuator."},{"location":"Gateway/Files/comms__protocol_8h/#attributes","title":"Attributes","text":"Name const uint8_t keys const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMilR unsigned long prevMil int msgCount cppQueue relay_q cppQueue msg_q aes256_context ctxt"},{"location":"Gateway/Files/comms__protocol_8h/#defines","title":"Defines","text":"Name IMPLEMENTATION RELAY_INTERVAL MAX_JSON_PAYLOAD_SIZE MAX_R_QUEUE_SIZE MAX_QUEUE_SIZE MAX_N_RETRY TIMEOUT_INTERVAL BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE KEY_SIZE MAX_MSG_ID BROADCAST_ID"},{"location":"Gateway/Files/comms__protocol_8h/#detailed-description","title":"Detailed Description","text":"<p>Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Gateway/Files/comms__protocol_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"Gateway/Files/comms__protocol_8h/#typedef-payload","title":"typedef Payload","text":"<pre><code>typedef struct strPayload Payload;\n</code></pre> <p>Data structure that holds the data for all the fields in the payload. </p>"},{"location":"Gateway/Files/comms__protocol_8h/#typedef-msg","title":"typedef Msg","text":"<pre><code>typedef struct strMsg Msg;\n</code></pre> <p>Data structure that holds the encrypted payload along with other important fields. </p>"},{"location":"Gateway/Files/comms__protocol_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_rxmode","title":"function LoRa_rxMode","text":"<pre><code>void LoRa_rxMode()\n</code></pre> <p>Sets the LoRa radio to receive mode. </p> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_txmode","title":"function LoRa_txMode","text":"<pre><code>void LoRa_txMode()\n</code></pre> <p>Sets the LoRa radio to transmit mode. </p> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-lora_sendmessage","title":"function LoRa_sendMessage","text":"<pre><code>void LoRa_sendMessage(\n    byte * message,\n    byte nodeID\n)\n</code></pre> <p>Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. </p> <p>Parameters: </p> <ul> <li>message message to send </li> <li>nodeID ID of the destination node </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-mymin","title":"function mymin","text":"<pre><code>int mymin(\n    int a,\n    int b\n)\n</code></pre> <p>returns the minimum value between two integers </p> <p>Parameters: </p> <ul> <li>a first integer to compare </li> <li>b second integer to compare </li> </ul> <p>Return: int the smaller between a and b </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-decryptmsg","title":"function decryptMsg","text":"<pre><code>char * decryptMsg(\n    char msg[MAX_PAYLOAD_SIZE+1]\n)\n</code></pre> <p>Decrypts a message string using the AES256 algorythm with the corresponding node key. </p> <p>Parameters: </p> <ul> <li>msg message string to be decrypted </li> </ul> <p>Return: char* an array of characters containing the decrypted message </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-onreceive","title":"function onReceive","text":"<pre><code>void onReceive(\n    int packetSize\n)\n</code></pre> <p>Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. Finally, calls constructJsonAndAddToQueue to build a json message destined for the server. </p> <p>Parameters: </p> <ul> <li>packetSize size of the incoming message in bytes </li> </ul>"},{"location":"Gateway/Files/comms__protocol_8h/#function-ontxdone","title":"function onTxDone","text":"<pre><code>void onTxDone()\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#function-encrypt","title":"function encrypt","text":"<pre><code>byte * encrypt(\n    char msg[MAX_PAYLOAD_SIZE]\n)\n</code></pre> <p>Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. </p> <p>Parameters: </p> <ul> <li>msg message array to be decrypted </li> </ul> <p>Return: byte* a byte array containing the encrypted message </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendack","title":"function sendAck","text":"<pre><code>void sendAck(\n    byte msgID,\n    byte nodeID\n)\n</code></pre> <p>Send an acknowledge message confirming the reception of an uplink transmission. </p> <p>Parameters: </p> <ul> <li>msgID ID of the message being acknowledged </li> <li>nodeID ID of the destination node </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-relaymsgfromqueuetoserver","title":"function relayMsgFromQueueToServer","text":"<pre><code>void relayMsgFromQueueToServer(\n    unsigned long currentMillis\n)\n</code></pre> <p>Get a message from the relay queue and send it to the server via serial communication. </p> <p>Parameters: </p> <ul> <li>currentMillis current time in millisenconds since boot </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-constructjsonandaddtoqueue","title":"function constructJsonAndAddToQueue","text":"<pre><code>void constructJsonAndAddToQueue(\n    Payload p\n)\n</code></pre> <p>Builds a json string containg the message information and adds the string to the relay queue. </p> <p>Parameters: </p> <ul> <li>p payload structure containing the message information along with RSSI, SNR and battery voltage </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-relaydownlinkmsg","title":"function relayDownlinkMsg","text":"<pre><code>void relayDownlinkMsg(\n    char * dlMsg\n)\n</code></pre> <p>Relays the downlink messages received from the server to the corresponding node. Formats the message into a compact form. </p> <p>Parameters: </p> <ul> <li>dlMsg character array containing the downlink message to be relayed </li> </ul>"},{"location":"Gateway/Files/comms__protocol_8h/#function-getmsgfromqueueandsend","title":"function getMsgFromQueueAndSend","text":"<pre><code>void getMsgFromQueueAndSend(\n    unsigned long currentMillis\n)\n</code></pre> <p>Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. </p> <p>Parameters: </p> <ul> <li>currentMillis current time in millisenconds since boot </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendstatusrequest","title":"function sendStatusRequest","text":"<pre><code>void sendStatusRequest(\n    byte nodeID\n)\n</code></pre> <p>Send a status request message asking for a specific node to respond with a status update. </p> <p>Parameters: </p> <ul> <li>nodeID ID of the destination node </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#function-sendactuatorcontrol","title":"function sendActuatorControl","text":"<pre><code>void sendActuatorControl(\n    byte nodeID,\n    byte actID,\n    byte actVal\n)\n</code></pre> <p>Send a control message to set a value for a node's actuator. </p> <p>Parameters: </p> <ul> <li>nodeID ID of the destination node </li> <li>actID ID of the actuator to control </li> <li>actVal Value to set the actuator to </li> </ul> <p>Return: void </p>"},{"location":"Gateway/Files/comms__protocol_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Gateway/Files/comms__protocol_8h/#variable-keys","title":"variable keys","text":"<pre><code>const uint8_t keys = {{ \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f\n},{ \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n},\n{ \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f\n},\n{ \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f\n},{ \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f\n}};\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-frequency","title":"variable frequency","text":"<pre><code>const long frequency = 868E6;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-txpower","title":"variable txPower","text":"<pre><code>const int txPower = 14;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-spreadingfactor","title":"variable spreadingFactor","text":"<pre><code>const int spreadingFactor = 7;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-signalbandwidth","title":"variable signalBandwidth","text":"<pre><code>const long signalBandwidth = 125E3;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-codingratedenominator","title":"variable codingRateDenominator","text":"<pre><code>const int codingRateDenominator = 5;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-currmsg","title":"variable currMsg","text":"<pre><code>int currMsg;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-count","title":"variable count","text":"<pre><code>int count;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-prevmilr","title":"variable prevMilR","text":"<pre><code>unsigned long prevMilR;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-prevmil","title":"variable prevMil","text":"<pre><code>unsigned long prevMil;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-msgcount","title":"variable msgCount","text":"<pre><code>int msgCount;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-relay_q","title":"variable relay_q","text":"<pre><code>cppQueue relay_q;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-msg_q","title":"variable msg_q","text":"<pre><code>cppQueue msg_q;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#variable-ctxt","title":"variable ctxt","text":"<pre><code>aes256_context ctxt;\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Gateway/Files/comms__protocol_8h/#define-implementation","title":"define IMPLEMENTATION","text":"<pre><code>#define IMPLEMENTATION FIFO\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-relay_interval","title":"define RELAY_INTERVAL","text":"<pre><code>#define RELAY_INTERVAL 100\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_json_payload_size","title":"define MAX_JSON_PAYLOAD_SIZE","text":"<pre><code>#define MAX_JSON_PAYLOAD_SIZE 120\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_r_queue_size","title":"define MAX_R_QUEUE_SIZE","text":"<pre><code>#define MAX_R_QUEUE_SIZE 2\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_queue_size","title":"define MAX_QUEUE_SIZE","text":"<pre><code>#define MAX_QUEUE_SIZE 5\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_n_retry","title":"define MAX_N_RETRY","text":"<pre><code>#define MAX_N_RETRY 3\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-timeout_interval","title":"define TIMEOUT_INTERVAL","text":"<pre><code>#define TIMEOUT_INTERVAL 3000\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-block_size","title":"define BLOCK_SIZE","text":"<pre><code>#define BLOCK_SIZE 16\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_payload_size","title":"define MAX_PAYLOAD_SIZE","text":"<pre><code>#define MAX_PAYLOAD_SIZE 16\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-enc_block_size","title":"define ENC_BLOCK_SIZE","text":"<pre><code>#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_enc_payload_size","title":"define MAX_ENC_PAYLOAD_SIZE","text":"<pre><code>#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-key_size","title":"define KEY_SIZE","text":"<pre><code>#define KEY_SIZE 32\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-max_msg_id","title":"define MAX_MSG_ID","text":"<pre><code>#define MAX_MSG_ID 256\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#define-broadcast_id","title":"define BROADCAST_ID","text":"<pre><code>#define BROADCAST_ID 0xFF\n</code></pre>"},{"location":"Gateway/Files/comms__protocol_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef COMMS_PROTOCOL_H\n#define COMMS_PROTOCOL_H\n\n#include &lt;Arduino.h&gt;\n#include &lt;SPI.h&gt;              \n#include &lt;LoRa.h&gt;\n#include \"gateway_serial_definitions.h\"\n#include &lt;cppQueue.h&gt;\n#include &lt;aes256.h&gt;\n\n#define  IMPLEMENTATION  FIFO\n\n// LoRa msg payload settings\n#define RELAY_INTERVAL 100\n#define MAX_JSON_PAYLOAD_SIZE 120\n#define MAX_R_QUEUE_SIZE 2\n#define MAX_QUEUE_SIZE 5\n#define MAX_N_RETRY 3\n#define TIMEOUT_INTERVAL 3000\n\n#define BLOCK_SIZE 16\n#define MAX_PAYLOAD_SIZE 16\n#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)\n#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1\n#define KEY_SIZE 32\n\n#define MAX_MSG_ID 256\n\n#define BROADCAST_ID 0xFF\n\n// Encryption keys\nconst uint8_t keys[][KEY_SIZE] = {{ //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f\n},{ //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n},\n{ //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f\n},\n{ //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f\n},{ //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f\n}};\n\n// LoRa Modem Settings\nconst long frequency = 868E6;\nconst int txPower = 14;\nconst int spreadingFactor = 7;\nconst long signalBandwidth = 125E3;\nconst int codingRateDenominator = 5;\n\ntypedef struct strPayload {\n  byte nodeID;\n  byte sensorID;\n  byte sensorVal;\n  byte msgID;\n  char flag;\n  int RSSI;\n  float SNR;\n  float VBAT;\n  double milis;\n} Payload;\n\ntypedef struct strMsg {\n  byte msg[MAX_ENC_PAYLOAD_SIZE];\n  byte msgID;\n  char flag;\n  byte nodeID;\n  byte actID;\n  byte actVal;\n} Msg;\n\nextern int currMsg;\nextern int count;\nextern unsigned long prevMilR;\nextern unsigned long prevMil;\nextern int msgCount;\n\nextern cppQueue relay_q;\nextern cppQueue msg_q;\nextern aes256_context ctxt;\n\nvoid LoRa_rxMode();\nvoid LoRa_txMode();\nvoid LoRa_sendMessage(byte *message, byte nodeID);\nint mymin(int a, int b);\nchar  *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]);\nvoid onReceive(int packetSize);\nvoid onTxDone();\nbyte *encrypt(char msg[MAX_PAYLOAD_SIZE]);\nvoid sendAck(byte msgID, byte nodeID);\nvoid relayMsgFromQueueToServer(unsigned long currentMillis);\nvoid constructJsonAndAddToQueue(Payload p);\nvoid relayDownlinkMsg(char *dlMsg);\nvoid getMsgFromQueueAndSend(unsigned long currentMillis);\nvoid sendStatusRequest(byte nodeID);\nvoid sendActuatorControl(byte nodeID, byte actID, byte actVal);\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Files/gateway__serial_8ino/","title":"gateway_serial.ino","text":"<p>Gateway script - send sensor data to gateway and receive commands from gateway.  More...</p>"},{"location":"Gateway/Files/gateway__serial_8ino/#functions","title":"Functions","text":"Name void setup()Arduino setup function. void loop()Arduino loop function."},{"location":"Gateway/Files/gateway__serial_8ino/#detailed-description","title":"Detailed Description","text":"<p>Gateway script - send sensor data to gateway and receive commands from gateway. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-09</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Gateway/Files/gateway__serial_8ino/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Gateway/Files/gateway__serial_8ino/#function-setup","title":"function setup","text":"<pre><code>void setup()\n</code></pre> <p>Arduino setup function. </p>"},{"location":"Gateway/Files/gateway__serial_8ino/#function-setup_1","title":"Function: setup","text":"<p>Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode</p> <p>void </p>"},{"location":"Gateway/Files/gateway__serial_8ino/#function-loop","title":"function loop","text":"<pre><code>void loop()\n</code></pre> <p>Arduino loop function. </p>"},{"location":"Gateway/Files/gateway__serial_8ino/#function-loop_1","title":"Function: loop","text":"<p>Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically.</p> <p>void </p>"},{"location":"Gateway/Files/gateway__serial_8ino/#source-code","title":"Source code","text":"<pre><code>\n#include \"comms_protocol.h\"\n\nvoid setup() {\n  Serial.begin(BAUD_RATE);\n\n  #if defined(ESP32)\n    SPI.begin(SCK, MISO, MOSI, SS);\n  #endif\n\n  LoRa.setPins(SS, RST, DIO0);\n\n  if (!LoRa.begin(frequency)) {\n    Serial.write(\"LoRa init failed.\\n\");\n    while (true);                       // if failed, do nothing\n  }\n\n  LoRa.setTxPower(txPower);\n  LoRa.setSignalBandwidth(signalBandwidth);\n  LoRa.setCodingRate4(codingRateDenominator);\n  LoRa.setSpreadingFactor(spreadingFactor);\n\n  LoRa.setSyncWord(netID);\n  LoRa.enableCrc();\n  LoRa_rxMode();\n\n  prevMil = millis();\n\n  Serial.write(\"Startup complete\\n\");\n}\n\nvoid loop()\n{\n  unsigned long currentMillis = millis();\n\n  int packetSize = LoRa.parsePacket();\n  if (packetSize) {\n    onReceive(packetSize);\n  }\n\n  // Receive downlink msgs from server\n  if (Serial.available() &gt; 0) {\n    String dlMsg = Serial.readString();\n    char msg[dlMsg.length()];\n    dlMsg.toCharArray(msg, dlMsg.length());\n\n    relayDownlinkMsg(msg);\n  }\n\n  //if((currentMillis-prevMilR) &gt; RELAY_INTERVAL){\n  relayMsgFromQueueToServer(currentMillis);\n  //}\n\n  if((currentMillis-prevMil) &gt; TIMEOUT_INTERVAL){\n    //sendStatusRequest(1);\n    getMsgFromQueueAndSend(currentMillis);\n  }\n}\n</code></pre> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/","title":"gateway_serial_definitions.h","text":""},{"location":"Gateway/Files/gateway__serial__definitions_8h/#attributes","title":"Attributes","text":"Name const int gatewayID const byte netID"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#defines","title":"Defines","text":"Name BAUD_RATE SS RST DIO0"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Gateway/Files/gateway__serial__definitions_8h/#variable-gatewayid","title":"variable gatewayID","text":"<pre><code>const int gatewayID = 0xFF;\n</code></pre>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#variable-netid","title":"variable netID","text":"<pre><code>const byte netID = 0xF3;\n</code></pre>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-baud_rate","title":"define BAUD_RATE","text":"<pre><code>#define BAUD_RATE 9600\n</code></pre>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-ss","title":"define SS","text":"<pre><code>#define SS 10\n</code></pre>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-rst","title":"define RST","text":"<pre><code>#define RST 9\n</code></pre>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#define-dio0","title":"define DIO0","text":"<pre><code>#define DIO0 2\n</code></pre>"},{"location":"Gateway/Files/gateway__serial__definitions_8h/#source-code","title":"Source code","text":"<pre><code>/*\n * Header file for the gateway program. Contains hardware pinouts,\n * LoRa modem configs and gateway settings\n */\n\n#ifndef GATEWAY_SERIAL_DEFINITIONS_H\n#define GATEWAY_SERIAL_DEFINITIONS_H\n\n// Baud rate for serial communication\n#define BAUD_RATE 9600\n\n// SPI pinout for TTGO boards\n//#define SCK 5\n//#define MISO 19\n//#define MOSI 27\n\n// LoRa Modem Pinout for boards with the Dragino LoRa shield\n#define SS 10\n#define RST 9\n#define DIO0 2  \n\n// Gateway Settings\nconst int gatewayID = 0xFF;\nconst byte netID = 0xF3;\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Modules/","title":"Modules","text":"<p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Namespaces/","title":"Namespaces","text":"<p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Gateway/Pages/","title":"Pages","text":"<p>Updated on 2024-02-06 at 12:07:58 +0000</p>"},{"location":"Network_Manager/Classes/","title":"Classes","text":"<ul> <li>namespace network_manager </li> </ul> <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Examples/","title":"Examples","text":"<p>Updated on 2024-02-06 at 12:08:01 +0000</p>"},{"location":"Network_Manager/Files/","title":"Files","text":"<ul> <li>dir /sensor_network/network_manager/src <ul> <li>file /sensor_network/network_manager/src/network_manager.py </li> <li>file /sensor_network/network_manager/src/stats_plotter.m </li> </ul> </li> </ul> <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"/sensor_network/network_manager/src","text":""},{"location":"Network_Manager/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Name /sensor_network/network_manager/src/network_manager.py /sensor_network/network_manager/src/stats_plotter.m <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Files/network__manager_8py/","title":"/sensor_network/network_manager/src/network_manager.py","text":""},{"location":"Network_Manager/Files/network__manager_8py/#namespaces","title":"Namespaces","text":"Name network_manager"},{"location":"Network_Manager/Files/network__manager_8py/#source-code","title":"Source code","text":"<pre><code>#!/usr/bin/env python3\n\n\n\nimport serial\nfrom parse import parse\nimport threading\nimport PySimpleGUI as sg\nimport json \nfrom datetime import datetime\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\nplt.rcParams.update({'font.size': 6})\nimport yaml\nimport csv\nimport time\n\n\n# Global variables declaration.\nmaxNum = 5\ngateway_status = \"Offline\"\n\n_VARS = {'rssi_canvas': None,\n         'snr_canvas': None,\n         'dl_msgs': {\n            'timestamps': list(),\n            'nodeID': list(),\n            'msgID': list(),\n            'delay': list(),\n         }}\n\n\n\ndef network_test():\n    runs = 5\n    msg_delay = 3\n    print('Starting test!')\n    for i in range(runs):\n        global stop_threads\n        for node in nodes:\n            if stop_threads:\n                return\n            data = 's,' + str(node['id'])\n            send_dl_msg('s,2')\n            #print(datetime.now(), data)\n            time.sleep(msg_delay)\n    print('Test finished!')\n\ndef idxFromID(id):\n    idx = -1\n\n    for i in range(len(nodes)):\n        if nodes[i]['id'] == id:\n            idx = i\n            break       \n    return idx\n\n\n\ndef draw_figure(canvas, figure):\n    figure_canvas_agg = FigureCanvasTkAgg(figure, canvas)\n    figure_canvas_agg.draw_idle()\n    figure_canvas_agg.get_tk_widget().pack(side='top', fill='both', expand=1)\n    return figure_canvas_agg\n\n\ndef send_dl_msg(data):\n    data = bytes(data, encoding='utf-8')\n    ser.write(data)\n    ser.write(bytes(\"\\n\", encoding='utf-8'))\n    ser.flush()\n\n\ndef export_data(path):\n    #print(path)\n    with open(path, 'w', newline='') as csvfile:\n        writer = csv.writer(csvfile, delimiter=',', quotechar='|', quoting=csv.QUOTE_MINIMAL)\n        for node in nodes:\n            for i in range(len(node['timestamps'])):\n                writer.writerow([node['timestamps'][i], node['delay_list'][i], node['msgID_list'][i], node['id'], node['rssi_list'][i], node['snr_list'][i], node['battery_list'][i], '0'])\n        for i in range(len(_VARS['dl_msgs']['timestamps'])):\n            writer.writerow([_VARS['dl_msgs']['timestamps'][i], _VARS['dl_msgs']['delay'][i], _VARS['dl_msgs']['msgID'][i], _VARS['dl_msgs']['nodeID'][i], 0, 0, 0, '1'])\n    print('Data exported!')\n    #timestamp, nodeID, rssi, snr, battery, DL/UL\n    #if DL we only care about timestamp and nodeID\n    # set up custom commands for DLMSG: test1, test2 -&gt; execute predetermined tests and save data\n\n\ndef gui():\n    sg.theme('BrownBlue') \n    global active_nodes\n    global nodes\n    global total_nodes\n\n    node_keys = {'Node ' + str(node['id']): node for node in nodes}\n\n    sensor_pane_layout = [ sg.Column([\n        [sg.Text('Sensor ID:', background_color='white', text_color='black'), sg.Text('id', background_color='white', text_color='black', key='_SID'+str(i)+'_')],\n        [sg.Text('Sensor Name:', background_color='white', text_color='black'), sg.Text('name', background_color='white', text_color='black', key='_SNAME'+str(i)+'_')],\n        [sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('never', background_color='white', text_color='black', key='_SLA'+str(i)+'_')],\n        [sg.Text('State:', background_color='white', text_color='black'), sg.Text('unknown', background_color='white', text_color='black', key='_SSTATE'+str(i)+'_')],\n                        ], expand_y = True, background_color='white', key='_SCOL'+str(i)+'_', visible=False) for i in range(maxNum)]\n\n    actuator_pane_layout = [ sg.Column([\n        [sg.Text('Actuator ID:', background_color='white', text_color='black'), sg.Text('id', background_color='white', text_color='black', key='_AID'+str(i)+'_')],\n        [sg.Text('Actuator Name:', background_color='white', text_color='black'), sg.Text('name', background_color='white', text_color='black', key='_ANAME'+str(i)+'_')],\n        [sg.Text('Last Activity:', background_color='white', text_color='black'), sg.Text('never', background_color='white', text_color='black', key='_ALA'+str(i)+'_')],\n        [sg.Text('State:', background_color='white', text_color='black'), sg.Text('unknown', background_color='white', text_color='black', key='_ASTATE'+str(i)+'_')],\n        [sg.Button('ON', key='_AON'+str(i)+'_'),sg.Button('OFF', key='_AOFF'+str(i)+'_')],\n                        ], expand_y = True, background_color='white', key='_ACOL'+str(i)+'_', visible=False) for i in range(maxNum)]\n\n    status_tab_layout = [\n        [\n            sg.Text('Node State:', background_color='white', text_color='black'),\n            sg.Text('Offline', key='_NSTATE_', background_color='white', text_color='red')\n        ],\n        [\n            sg.Text('Node Location:', background_color='white', text_color='black'),\n            sg.Text('', key='_NLOCATION_', background_color='white', text_color='black')\n        ],\n        [\n            sg.Text('Last Activity:', background_color='white', text_color='black'),\n            sg.Text('None', key='_NLASTACTIVITY_', background_color='white', text_color='black')\n        ],\n        [\n            sg.Text('Sensors:', background_color='white', text_color='black'),\n        ],\n        [\n            sg.Column( layout=[sensor_pane_layout], key='_SENSORSPANE_', scrollable = True, size = (None, 110), expand_x=True)\n        ],\n        [\n            sg.Text('Actuators:', background_color='white', text_color='black'),\n        ],\n        [\n            sg.Column( layout=[actuator_pane_layout], key='_ACTUATORSPANE_', scrollable = True, size = (None, 145), expand_x=True)\n        ]\n    ]\n    info_tab_layout = [\n        [\n            sg.Text('Packets sent:', background_color='white', text_color='black'),\n            sg.Text('0', key='_PACKETSSENT_', background_color='white', text_color='black')\n        ],\n        #[\n        #   sg.Text('Packets received:', background_color='white', text_color='black'),\n        #   sg.Text('0', key='_PACKETSRECEIVED_', background_color='white', text_color='black')\n        #],\n        [\n            sg.Text('Average RSSI:', background_color='white', text_color='black'),\n            sg.Text('', key='_AVGRSSI_', background_color='white', text_color='black')\n        ],\n        [\n            sg.Text('Average SNR:', background_color='white', text_color='black'),\n            sg.Text('', key='_AVGSNR_', background_color='white', text_color='black')\n        ],\n        [\n            sg.Text('Battery Level (V):', background_color='white', text_color='black'),\n            sg.Text('', key='_BAT_', background_color='white', text_color='black')\n        ],\n        [\n            sg.Column(layout = [\n                [\n                    sg.Frame(layout = [[sg.Canvas(key='rssi_canvas', background_color=sg.theme_background_color())]], title = \"RSSI vs Packet\", size=(250,250)),\n                    sg.Frame(layout = [[sg.Canvas(key='snr_canvas', background_color=sg.theme_background_color())]], title = \"SNR vs Packet\", size=(250,250))\n                ]\n            ], scrollable=False, expand_x = True, expand_y = True)\n        ]\n    ]\n\n    layout = [  [\n                    sg.Text('Active Nodes:'),\n                    sg.Text(str(active_nodes), key='_ACTIVENODES_'),\n                    sg.Text('/'),\n                    sg.Text( str(total_nodes), key='_TOTALNODES_')\n                ],\n                [\n                    sg.Text('Gateway Status:'),\n                    sg.Text(gateway_status, key='_GATEWAYSTATUS_', text_color='red'),\n                    sg.Push(),\n                    sg.Text('Boot time:'),\n                    sg.Text('', key='_BOOTTIME_')\n                ],\n                [sg.Text('Send Downlink Message'), sg.InputText(key='_DLMSG_'), sg.Button('Send')],\n                [sg.HorizontalSeparator()],\n                [\n                    sg.Listbox(values=list(node_keys.keys()), size=(15, 27), key='_LIST_', enable_events=True, select_mode='LISTBOX_SELECT_MODE_SINGLE', default_values=['Node 1']),\n                    sg.VerticalSeparator(),\n                    sg.TabGroup([\n                        [sg.Tab(title='Node 1 Status', key='_STATUSTAB_', background_color='white', layout = status_tab_layout)],\n                        [sg.Tab(title='Node 1 Stats', key='_STATSTAB_', background_color='white', layout = info_tab_layout)]\n                    ],  tab_location='topleft', \n                        size=(600,None),\n                        selected_background_color='white', \n                        tab_background_color=sg.theme_background_color(), \n                        selected_title_color=sg.theme_background_color(), \n                        title_color='white'                 \n                    )\n                ],\n                [sg.Output(size=(119,8))],\n                [\n                    sg.Button('Rescan Network', key='_RSNET_'), \n                    sg.Button('Start Test', key='_TEST_'), \n                    sg.InputText(visible=False, enable_events=True, key='export_data_path'),\n                    sg.FileSaveAs('Export data', key='_EXPORT_', file_types=(('CSV', '.csv'),)),\n                    sg.Push(),\n                    sg.Button('Exit')\n                ] \n            ]\n\n    global window\n    window = sg.Window('Sensor Network Manager', layout, finalize=True)\n\n    for i in range(len(nodes)):\n        plt.figure(num=0)\n        plt.plot([],[],'.k')\n        #nodes[i]['rssi_plot_canvas'] = FigureCanvasTkAgg(plt.figure(num=0), window.Element('rssi_canvas').TKCanvas)\n        _VARS['rssi_canvas'] = FigureCanvasTkAgg(plt.figure(num=0), window.Element('rssi_canvas').TKCanvas)\n        #nodes[i]['rssi_plot_canvas'].get_tk_widget().hide()\n        nodes[i]['rssi_list'] = list()\n        plt.figure(num=1)\n        plt.plot([],[],'.k')\n        #nodes[i]['snr_plot_canvas'] = FigureCanvasTkAgg(plt.figure(num=1), window.Element('snr_canvas').TKCanvas)\n        _VARS['snr_canvas'] = FigureCanvasTkAgg(plt.figure(num=1), window.Element('snr_canvas').TKCanvas)\n        nodes[i]['snr_list'] = list()\n\n        nodes[i]['timestamps'] = list()\n        nodes[i]['battery_list'] = list()\n        nodes[i]['msgID_list'] = list()\n        nodes[i]['delay_list'] = list()\n\n    while True:\n        event, values = window.read(timeout = 200)\n        if event == sg.WIN_CLOSED or event == 'Exit': \n            break\n        if event == '_TEST_':\n            global nt_thread\n            nt_thread.start()\n        if event == 'export_data_path':\n            path = values['export_data_path']\n            export_data(path)\n        if event == 'Send' and len(values['_DLMSG_']):\n            data = values['_DLMSG_']\n            send_dl_msg(data)\n            window.Element('_DLMSG_').update(value=\"\")\n\n        if event == '_LIST_' and len(values['_LIST_']): \n            r = parse(\"[\\'Node {}\\']\", str(values['_LIST_']))\n            idx = int(r[0])\n            idx = idxFromID(idx)\n            window.Element('_STATUSTAB_').update(title='Node ' + str(nodes[idx]['id']) + ' Status')\n            window.Element('_STATSTAB_').update(title='Node ' + str(nodes[idx]['id']) + ' Stats')\n            updateTabs(idx)\n        if event == '_RSNET_':\n            active_nodes = 0\n            window.Element('_ACTIVENODES_').update(value=str(active_nodes))\n            for i in range(len(nodes)):\n                nodes[i][\"state\"] = 0 \n            r = parse(\"[\\'Node {}\\']\", str(values['_LIST_']))\n            idx = int(r[0])-1\n            #updateTabs(idx)\n            send_dl_msg(\"s,-1\\n\")\n        if '_AON' in event:\n            r = parse(\"[\\'Node {}\\']\", str(values['_LIST_']))\n            nID = int(r[0])\n            r = parse(\"_AON{}_\", str(event))\n            actID = int(r[0])\n            actID = nodes[nID-1]['actuators'][actID]['id']\n\n            data = 'c,' + str(nID) + ',' + str(actID) + ',1'\n            send_dl_msg(data)\n\n        if '_AOFF' in event:\n            r = parse(\"[\\'Node {}\\']\", str(values['_LIST_']))\n            nID = int(r[0])\n            r = parse(\"_AOFF{}_\", str(event))\n            actID = int(r[0])\n            actID = nodes[nID-1]['actuators'][actID]['id']\n\n            data = 'c,' + str(nID) + ',' + str(actID) + ',0'\n            send_dl_msg(data)\n\n        window.refresh()\n\n    window.close()\n\nfirstTime = True\n\n\ndef updateTabs(idx):\n    global nodes\n    global window\n\n    window.Element('_NSTATE_').update(value='Online' if int(nodes[idx]['state']) else 'Offline', text_color='green' if int(nodes[idx]['state']) else 'red')\n    window.Element('_NLASTACTIVITY_').update(value=str(nodes[idx]['last_activity']))\n    window.Element('_NLOCATION_').update(value=str(nodes[idx]['location']))\n\n    window.Element('_PACKETSSENT_').update(value=str(nodes[idx]['packets_sent']))\n    #window.Element('_PACKETSRECEIVED_').update(value=str(nodes[idx]['packets_received']))\n    window.Element('_PACKETSSENT_').update(value=str(nodes[idx]['packets_sent']))\n    window.Element('_AVGRSSI_').update(value=str(nodes[idx]['avg_rssi']))\n    window.Element('_AVGSNR_').update(value=str(nodes[idx]['avg_snr']))\n    window.Element('_BAT_').update(value=str(nodes[idx]['battery']))\n\n    # \\\\  -------- PYPLOT -------- //\n    if(len(nodes[idx]['rssi_list'])&gt;0):\n        #nodes[idx]['rssi_plot_canvas'].get_tk_widget().forget()\n        _VARS['rssi_canvas'].get_tk_widget().forget()\n        plt.figure(num=0)\n        plt.clf()\n        plt.plot(range(1,len(nodes[idx]['rssi_list'])+1), nodes[idx]['rssi_list'], 'bo-', linewidth=0.5, markersize=3)\n        plt.xticks(np.arange(1, len(nodes[idx]['rssi_list'])+1))\n        plt.ylim(-120, 20)\n        #nodes[idx]['rssi_plot_canvas'] = draw_figure(window.Element('rssi_canvas').TKCanvas, plt.figure(num=0))\n        _VARS['rssi_canvas'] = draw_figure(window.Element('rssi_canvas').TKCanvas, plt.figure(num=0))\n\n        #nodes[idx]['snr_plot_canvas'].get_tk_widget().forget()\n        _VARS['snr_canvas'].get_tk_widget().forget()\n        plt.figure(num=1)\n        plt.clf()\n        plt.plot(range(1,len(nodes[idx]['snr_list'])+1), nodes[idx]['snr_list'], 'bo-', linewidth=0.5, markersize=3)\n        plt.xticks(np.arange(1, len(nodes[idx]['snr_list'])+1))\n        plt.ylim(-15, 15)\n        #nodes[idx]['snr_plot_canvas'] = draw_figure(window.Element('snr_canvas').TKCanvas, plt.figure(num=1))\n        _VARS['snr_canvas'] = draw_figure(window.Element('snr_canvas').TKCanvas, plt.figure(num=1))\n    # \\\\  -------- PYPLOT -------- //\n\n    for i in range(maxNum):\n        if i &lt; len(nodes[idx]['sensors']):\n            window.Element('_SCOL'+str(i)+'_').update(visible=True)\n            window.Element('_SID'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['id']))\n            window.Element('_SNAME'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['name']))\n            window.Element('_SLA'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['last_activity']))\n            window.Element('_SSTATE'+str(i)+'_').update(value=str(nodes[idx]['sensors'][i]['state']))\n        else:\n            window.Element('_SCOL'+str(i)+'_').update(visible=False)\n\n\n    for i in range(maxNum):\n        if i &lt; len(nodes[idx]['actuators']):\n            window.Element('_ACOL'+str(i)+'_').update(visible=True)\n            window.Element('_AID'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['id']))\n            window.Element('_ANAME'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['name']))\n            window.Element('_ALA'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['last_activity']))\n            window.Element('_ASTATE'+str(i)+'_').update(value=str(nodes[idx]['actuators'][i]['state']))\n        else:\n            window.Element('_ACOL'+str(i)+'_').update(visible=False)\n\n    window.Element('_SENSORSPANE_').contents_changed()\n    window.Element('_ACTUATORSPANE_').contents_changed()\n\n\n\ndef serial_comm():\n    while  True:\n        global stop_threads\n        if stop_threads:\n            break\n        global nodes\n        global window\n\n        line = ser.readline()\n        line = line.decode('utf-8', \"ignore\")\n        if(len(line) &gt; 4):\n            line = line.strip('rm').strip('\\n').rstrip()\n            if line == \"Startup complete\":\n                window.Element('_GATEWAYSTATUS_').update(value=line, text_color='#42cf68')\n                window.Element('_BOOTTIME_').update(value=datetime.now().strftime(\"%d/%m/%Y %H:%M:%S\"))\n            else:\n                try:\n                    print(datetime.now(), line)\n                    msg = json.loads(line)\n\n                    if(msg['f'] == 'd'):\n                        _VARS['dl_msgs']['nodeID'].append(msg['nID'])\n                        _VARS['dl_msgs']['timestamps'].append(datetime.now())\n                        _VARS['dl_msgs']['msgID'].append(msg['msgID'])\n                        _VARS['dl_msgs']['delay'].append(msg['t'])\n                    else:\n                        nidx = idxFromID(int(msg['nID']))\n                        now = datetime.now()\n                        dt_string = now.strftime(\"%d/%m/%Y %H:%M:%S\")\n\n                        if(int(msg['RSSI']) != 0):\n                            nodes[idxFromID(int(msg['nID']))]['packets_sent'] += 1  \n                            t_packets = nodes[idxFromID(int(msg['nID']))]['packets_sent'] + nodes[idxFromID(int(msg['nID']))]['packets_received']\n                            avg_rssi = float(nodes[idxFromID(int(msg['nID']))]['avg_rssi']) * float(t_packets-1)/t_packets + float(msg['RSSI']) * float(1/t_packets)\n                            avg_snr = nodes[idxFromID(int(msg['nID']))]['avg_snr'] * float(t_packets-1)/t_packets + float(msg['SNR']) * float(1/t_packets)\n                            bat = float(msg['VBAT'])\n\n                            nodes[idxFromID(int(msg['nID']))]['avg_rssi'] = round(avg_rssi, 2)\n                            nodes[idxFromID(int(msg['nID']))]['avg_snr'] = round(avg_snr, 2)\n                            nodes[idxFromID(int(msg['nID']))]['battery'] = round(bat, 1)\n\n                            for node in nodes:\n                                if int(node['id']) == int(msg['nID']):\n                                    node['rssi_list'] += [float(msg['RSSI'])]\n                                    node['snr_list'] += [float(msg['SNR'])]\n                                    node['battery_list'] += [float(msg['VBAT'])]\n                                    node['timestamps'] += [datetime.now()]\n                                    node['msgID_list'] += [int(msg['msgID'])]\n                                    node['delay_list'] += [msg['t']]\n\n                        if((int(msg['nID']) != 255) and (msg['f'] == 's')):\n                            nodes[idxFromID(int(msg['nID']))]['state'] = int(msg['state'])\n\n                            active_nodes = sum(node[\"state\"] == 1 for node in nodes)\n                            window.Element('_ACTIVENODES_').update(value=str(active_nodes))\n                            nodes[nidx]['last_activity'] = 'state update' + ' at ' + dt_string\n                            if(nidx == window.Element('_LIST_').get_indexes()[0]):\n                                updateTabs(nidx)\n\n                        if((int(msg['nID']) != 255) and (msg['f'] == 'u')):\n                            nodes[nidx]['last_activity'] = str(nodes[nidx]['sensors'][int(msg['sID'])-1]['name']) + ' with value: ' + msg['sVal'] + ' at ' + dt_string\n                            window.Element('_LIST_').update(set_to_index=nidx)\n                            window.Element('_STATUSTAB_').update(title='Node ' + msg['nID'] + ' Status')\n                            window.Element('_STATSTAB_').update(title='Node ' + msg['nID'] + ' Info')\n\n\n                            nodes[nidx]['sensors'][int(msg['sID'])-1]['last_activity'] = dt_string\n                            nodes[nidx]['sensors'][int(msg['sID'])-1]['state'] = msg['sVal']\n\n                            nodes[idxFromID(int(msg['nID']))]['state'] = 1\n                            active_nodes = sum(node[\"state\"] == 1 for node in nodes)\n                            window.Element('_ACTIVENODES_').update(value=str(active_nodes))\n                            updateTabs(nidx)\n                        if((int(msg['nID']) != 255) and (msg['f'] == 'a')):\n                            nodes[nidx]['last_activity'] = str(nodes[nidx]['actuators'][int(msg['actID'])-1]['name']) + ' with value: ' + msg['actVal'] + ' at ' + dt_string\n                            window.Element('_LIST_').update(set_to_index=nidx)\n                            window.Element('_STATUSTAB_').update(title='Node ' + msg['nID'] + ' Status')\n                            window.Element('_STATSTAB_').update(title='Node ' + msg['nID'] + ' Info')\n                            nodes[nidx]['actuators'][int(msg['actID'])-1]['last_activity'] = dt_string\n                            nodes[nidx]['actuators'][int(msg['actID'])-1]['state'] = msg['actVal']\n                            nodes[idxFromID(int(msg['nID']))]['state'] = 1\n                            active_nodes = sum(node[\"state\"] == 1 for node in nodes)\n                            window.Element('_ACTIVENODES_').update(value=str(active_nodes))\n                            if(nidx == window.Element('_LIST_').get_indexes()[0]):\n                                updateTabs(nidx)\n\n                except:\n                    continue\n                    #print(\"ERROR reading from serial!!\")\n\nsc_thread = threading.Thread(target=serial_comm)\nnt_thread = threading.Thread(target=network_test)\n\n\ndef main():\n    global active_nodes\n    active_nodes = 0\n    global total_nodes\n    global ser\n    global nodes\n    global stop_threads\n    stop_threads = False\n\n    with open(\"../config/wsn_config.yaml\", \"r\") as stream:\n        try:\n            config = yaml.safe_load(stream)\n        except yaml.YAMLError as exc:\n            print(exc)\n\n    gateways = config['wsn_config']['gateways']\n    for i in range(len(gateways)):\n        gateways_data = {\n            'state': 0\n        }\n        gateways[i] = {**gateways[i], **gateways_data}\n\n    nodes = config['wsn_config']['nodes']\n\n    node_data = {\n        'state': 0,\n        'last_activity': '',\n        'packets_sent':0,\n        'packets_received':0,\n        'avg_rssi': 0,\n        'avg_snr': 0,\n        'battery': 0,\n        'timestamps': list(),\n        'rssi_list': list(),\n        'snr_list': list(),\n        'battery_list': list(),\n        'msgID_list': list(),\n        'delay_list': list(),\n        'rssi_plot_canvas': None,\n        'snr_plot_canvas': None\n    }\n\n    sensors_data = {\n        'last_activity': '',\n        'state': None\n    }\n    actuators_data = {\n        'last_activity': '',\n        'state': None\n    }\n    for i in range(len(nodes)):\n        for j in range(len(nodes[i]['sensors'])):\n            nodes[i]['sensors'][j] = {**nodes[i]['sensors'][j], **sensors_data}\n        for j in range(len(nodes[i]['actuators'])):\n            nodes[i]['actuators'][j] = {**nodes[i]['actuators'][j], **actuators_data}\n        nodes[i] = {**nodes[i], **node_data}\n\n    total_nodes = len(nodes)\n\n    try:\n        ser = serial.Serial(gateways[0]['serial_port'], 9600, timeout=1)\n    except:\n        print(\"Serial port not available!\")\n        return\n\n    sc_thread.start()\n\n    gui()\n\n    stop_threads = True\n    sc_thread.join()\n    #nt_thread.join()\n\n    ser.close()\n\n    return 0\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n</code></pre> <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Files/stats__plotter_8m/","title":"/sensor_network/network_manager/src/stats_plotter.m","text":""},{"location":"Network_Manager/Files/stats__plotter_8m/#functions","title":"Functions","text":"Name virtual indxs(1 , 3 ) =0 indxs(a , 1 ) end if(nodeID(i)  ==2) indxs(b , 2 ) indxs(c , 3 ) end if(dir(i)  ==1) if(any(msgID(indxs(1:a, 1))==msgID(i)) ) if(any(msgID(indxs(1:b, 2))==msgID(i)) ) if(any(msgID(indxs(1:c, 3))==msgID(i)) ) end end avg_rssi(1 ) avg_rssi(2 ) avg_rssi(3 ) avg_snr(1 ) avg_snr(2 ) avg_snr(3 ) Calculate Average Delay Time avg_delay(1 ) avg_delay(2 ) avg_delay(3 ) Plot RSSI vs Time figure() hold on line('Color' , 'LineWidth' , lineThickness ) scatter(time(indxs(1:a, 1)) , rssi(indxs(1:a, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter(time(indxs(1:b, 2)) , rssi(indxs(1:b, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter(time(indxs(1:c, 3)) , rssi(indxs(1:c, 3)) , markerSize , 'MarkerEdgeColor' , ... % 'MarkerFaceColor' , ... % 'LineWidth' , 1 ) ylim() xlim() xtickformat('mm:ss' ) legend('Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1 Packets' , 'Node 2 Packets' , 'Node 3 Packets' , 'Location' , 'best' ) xlabel(\"Time (mm:ss)\" ) ylabel(\"RSSI (dB)\" ) hold on line('Color' ) scatter(time(indxs(1:a, 1)) , snr(indxs(1:a, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter(time(indxs(1:b, 2)) , snr(indxs(1:b, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter(time(indxs(1:c, 3)) , snr(indxs(1:c, 3)) , markerSize , 'MarkerEdgeColor' , ... % 'MarkerFaceColor' , ... % 'LineWidth' , 1 ) ylabel(\"SNR (dB)\" ) scatter(time(indxs(1:a, 1)) , delay(indxs(1:a, 1)) -delay(indxs_dl(1:d, 1)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter(time(indxs(1:b, 2)) , delay(indxs(1:b, 2)) -delay(indxs_dl(1:e, 2)) , markerSize , 'MarkerEdgeColor' , ... 'MarkerFaceColor' , ... 'LineWidth' , 1 ) scatter(time(indxs(1:c, 3)) , delay(indxs(1:c, 3)) -delay(indxs_dl(1:f, 3)) , markerSize , 'MarkerEdgeColor' , ... % 'MarkerFaceColor' , ... % 'LineWidth' , 1 ) legend('Node 1 Average' , 'Node 2 Average' , 'Node 3 Average' , 'Node 1' , 'Node 2' , 'Node 3' , 'Location' , 'best' ) ylabel(\"Packet Delay (ms)\" )"},{"location":"Network_Manager/Files/stats__plotter_8m/#attributes","title":"Attributes","text":"Name close all Array t delay msgID nodeID rssi snr battery dir n a b c d e f g h ii time ul_packets dl_packets Plot Settings markerSize lineThickness Claculate Average RSSI and SNR and AvgDelay prevID for i avg_delay_m mID avg_delay_m Calculate Package Loss packet_loss packet_loss node1_pl node2_pl node3_pl grid on"},{"location":"Network_Manager/Files/stats__plotter_8m/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs","title":"function indxs","text":"<pre><code>virtual indxs(\n    1 ,\n    3 \n) =0\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_1","title":"function indxs","text":"<pre><code>indxs(\n    a ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if","title":"function if","text":"<pre><code>end if(\n    nodeID(i)  ==2\n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_2","title":"function indxs","text":"<pre><code>indxs(\n    b ,\n    2 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-indxs_3","title":"function indxs","text":"<pre><code>indxs(\n    c ,\n    3 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if_1","title":"function if","text":"<pre><code>end if(\n    dir(i)  ==1\n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if_2","title":"function if","text":"<pre><code>if(\n    any(msgID(indxs(1:a, 1))==msgID(i)) \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if_3","title":"function if","text":"<pre><code>if(\n    any(msgID(indxs(1:b, 2))==msgID(i)) \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-if_4","title":"function if","text":"<pre><code>if(\n    any(msgID(indxs(1:c, 3))==msgID(i)) \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_rssi","title":"function avg_rssi","text":"<pre><code>end end avg_rssi(\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_rssi_1","title":"function avg_rssi","text":"<pre><code>avg_rssi(\n    2 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_rssi_2","title":"function avg_rssi","text":"<pre><code>avg_rssi(\n    3 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_snr","title":"function avg_snr","text":"<pre><code>avg_snr(\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_snr_1","title":"function avg_snr","text":"<pre><code>avg_snr(\n    2 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_snr_2","title":"function avg_snr","text":"<pre><code>avg_snr(\n    3 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_delay","title":"function avg_delay","text":"<pre><code>Calculate Average Delay Time avg_delay(\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_delay_1","title":"function avg_delay","text":"<pre><code>avg_delay(\n    2 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-avg_delay_2","title":"function avg_delay","text":"<pre><code>avg_delay(\n    3 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-figure","title":"function figure","text":"<pre><code>Plot RSSI vs Time figure()\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-line","title":"function line","text":"<pre><code>hold on line(\n    'Color' ,\n    'LineWidth' ,\n    lineThickness \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:a, 1)) ,\n    rssi(indxs(1:a, 1)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... 'MarkerFaceColor' ,\n    ... 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_1","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:b, 2)) ,\n    rssi(indxs(1:b, 2)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... 'MarkerFaceColor' ,\n    ... 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_2","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:c, 3)) ,\n    rssi(indxs(1:c, 3)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... % 'MarkerFaceColor' ,\n    ... % 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylim","title":"function ylim","text":"<pre><code>ylim()\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-xlim","title":"function xlim","text":"<pre><code>xlim()\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-xtickformat","title":"function xtickformat","text":"<pre><code>xtickformat(\n    'mm:ss' \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-legend","title":"function legend","text":"<pre><code>legend(\n    'Node 1 Average' ,\n    'Node 2 Average' ,\n    'Node 3 Average' ,\n    'Node 1 Packets' ,\n    'Node 2 Packets' ,\n    'Node 3 Packets' ,\n    'Location' ,\n    'best' \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-xlabel","title":"function xlabel","text":"<pre><code>xlabel(\n    \"Time (mm:ss)\" \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylabel","title":"function ylabel","text":"<pre><code>ylabel(\n    \"RSSI (dB)\" \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-line_1","title":"function line","text":"<pre><code>hold on line(\n    'Color' \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_3","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:a, 1)) ,\n    snr(indxs(1:a, 1)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... 'MarkerFaceColor' ,\n    ... 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_4","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:b, 2)) ,\n    snr(indxs(1:b, 2)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... 'MarkerFaceColor' ,\n    ... 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_5","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:c, 3)) ,\n    snr(indxs(1:c, 3)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... % 'MarkerFaceColor' ,\n    ... % 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylabel_1","title":"function ylabel","text":"<pre><code>ylabel(\n    \"SNR (dB)\" \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_6","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:a, 1)) ,\n    delay(indxs(1:a, 1)) -delay(indxs_dl(1:d, 1)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... 'MarkerFaceColor' ,\n    ... 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_7","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:b, 2)) ,\n    delay(indxs(1:b, 2)) -delay(indxs_dl(1:e, 2)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... 'MarkerFaceColor' ,\n    ... 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-scatter_8","title":"function scatter","text":"<pre><code>scatter(\n    time(indxs(1:c, 3)) ,\n    delay(indxs(1:c, 3)) -delay(indxs_dl(1:f, 3)) ,\n    markerSize ,\n    'MarkerEdgeColor' ,\n    ... % 'MarkerFaceColor' ,\n    ... % 'LineWidth' ,\n    1 \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-legend_1","title":"function legend","text":"<pre><code>legend(\n    'Node 1 Average' ,\n    'Node 2 Average' ,\n    'Node 3 Average' ,\n    'Node 1' ,\n    'Node 2' ,\n    'Node 3' ,\n    'Location' ,\n    'best' \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#function-ylabel_2","title":"function ylabel","text":"<pre><code>ylabel(\n    \"Packet Delay (ms)\" \n)\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-all","title":"variable all","text":"<pre><code>close all;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-array","title":"variable Array","text":"<pre><code>Array =readtable('test_results/field_test/field_A_crd5_sb125_sf11_50.csv');\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-t","title":"variable t","text":"<pre><code>t = datetime(table2array(Array(:,1)),'InputFormat','yyyy-MM-dd HH:mm:ss.SSSSSS');\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-delay","title":"variable delay","text":"<pre><code>delay = table2array(Array(:, 2));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-msgid","title":"variable msgID","text":"<pre><code>msgID = table2array(Array(:, 3));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-nodeid","title":"variable nodeID","text":"<pre><code>nodeID = table2array(Array(:, 4));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-rssi","title":"variable rssi","text":"<pre><code>rssi = table2array(Array(:, 5));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-snr","title":"variable snr","text":"<pre><code>snr = table2array(Array(:, 6));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-battery","title":"variable battery","text":"<pre><code>battery = table2array(Array(:, 7));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-dir","title":"variable dir","text":"<pre><code>dir = table2array(Array(:, 8));\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-n","title":"variable n","text":"<pre><code>n = size(msgID);\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-a","title":"variable a","text":"<pre><code>a =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-b","title":"variable b","text":"<pre><code>b =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-c","title":"variable c","text":"<pre><code>c =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-d","title":"variable d","text":"<pre><code>d =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-e","title":"variable e","text":"<pre><code>e =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-f","title":"variable f","text":"<pre><code>f =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-g","title":"variable g","text":"<pre><code>g =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-h","title":"variable h","text":"<pre><code>h =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-ii","title":"variable ii","text":"<pre><code>ii =0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-time","title":"variable time","text":"<pre><code>time = t-t(1);\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-ul_packets","title":"variable ul_packets","text":"<pre><code>ul_packets = 0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-dl_packets","title":"variable dl_packets","text":"<pre><code>dl_packets = 0;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-markersize","title":"variable markerSize","text":"<pre><code>Plot Settings markerSize = 15;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-linethickness","title":"variable lineThickness","text":"<pre><code>lineThickness = 0.0567;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-previd","title":"variable prevID","text":"<pre><code>Claculate Average RSSI and SNR and AvgDelay prevID = -1;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-i","title":"variable i","text":"<pre><code>for i =1:nif(dir(i) == 0)\n        if(nodeID(i) == 1)\n            a = a+1;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-avg_delay_m","title":"variable avg_delay_m","text":"<pre><code>avg_delay_m = mean(avg_delay);\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-mid","title":"variable mID","text":"<pre><code>mID = max(msgID);\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-packet_loss","title":"variable packet_loss","text":"<pre><code>avg_delay_m Calculate Package Loss packet_loss = (1 - ul_packets/dl_packets)*100;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-node1_pl","title":"variable node1_pl","text":"<pre><code>packet_loss node1_pl = (1- a/g)*100;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-node2_pl","title":"variable node2_pl","text":"<pre><code>node2_pl = (1- b/h)*100;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-node3_pl","title":"variable node3_pl","text":"<pre><code>node3_pl = (1- c/ii)*100;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#variable-on","title":"variable on","text":"<pre><code>grid on;\n</code></pre>"},{"location":"Network_Manager/Files/stats__plotter_8m/#source-code","title":"Source code","text":"<pre><code>close all;\n\nArray=readtable('test_results/field_test/field_A_crd5_sb125_sf11_50.csv');\n\nt = datetime(table2array(Array(:,1)),'InputFormat','yyyy-MM-dd HH:mm:ss.SSSSSS');\ndelay = table2array(Array(:, 2));\nmsgID = table2array(Array(:, 3));\nnodeID = table2array(Array(:, 4));\nrssi = table2array(Array(:, 5));\nsnr = table2array(Array(:, 6));\nbattery = table2array(Array(:, 7));\ndir = table2array(Array(:, 8));\n\nn = size(msgID);\nn = n(1);\n\na=0;b=0;c=0;d=0;e=0;f=0;g=0;h=0;ii=0;\n\ntime = t-t(1);\n\nul_packets = 0;\ndl_packets = 0;\n\n% Plot Settings\nmarkerSize = 15;\nlineThickness = 0.0567;\n\nindxs(1,3)=0;\n\n\n%% Claculate Average RSSI and SNR and AvgDelay\nprevID = -1;\n\nfor i=1:n\n    if(dir(i) == 0)\n        if(nodeID(i) == 1)\n            a = a+1;\n            indxs(a,1) = i;\n        end\n        if (nodeID(i) == 2)\n            b = b+1;\n            indxs(b,2) = i; \n        end\n        if (nodeID(i) == 3)\n            c = c+1;\n            indxs(c,3) = i;\n        end\n        ul_packets = ul_packets + 1;\n    end\n    if(dir(i) == 1)\n\n        if(nodeID(i) == 1)\n            if(nodeID(i) ~= prevID)\n                if(any(msgID(indxs(1:a,1)) == msgID(i)))\n                    d = d+1;\n                end\n            end\n            g = g+1;\n            if(any(msgID(indxs(1:a,1)) == msgID(i)))\n                indxs_dl(d,1) = i;\n            end\n        end\n        if (nodeID(i) == 2)\n            if(nodeID(i) ~= prevID)\n                if(any(msgID(indxs(1:b,2)) == msgID(i)))\n                    e = e+1;\n                end\n            end\n            h = h+1;\n            if(any(msgID(indxs(1:b,2)) == msgID(i)))\n                indxs_dl(e,2) = i; \n            end\n        end\n        if (nodeID(i) == 3)\n            if(nodeID(i) ~= prevID)\n                if(any(msgID(indxs(1:c,3)) == msgID(i)))\n                    f = f+1;\n                end\n            end\n            ii = ii+1;\n            if(any(msgID(indxs(1:c,3)) == msgID(i)))\n                indxs_dl(f,3) = i;\n            end\n        end\n        dl_packets = dl_packets + 1;\n        prevID = nodeID(i);\n    end\nend\n\navg_rssi(1) = mean(rssi(indxs(1:a,1)));\navg_rssi(2) = mean(rssi(indxs(1:b,2)));\n%avg_rssi(3) = mean(rssi(indxs(1:c,3)));\n\navg_snr(1) = mean(snr(indxs(1:a,1)));\navg_snr(2) = mean(snr(indxs(1:b,2)));\n%avg_snr(3) = mean(snr(indxs(1:c,3)));\n\n%% Calculate Average Delay Time\n\navg_delay(1) = mean(delay(indxs(1:a,1))-delay(indxs_dl(1:d,1)));\navg_delay(2) = mean(delay(indxs(1:b,2))-delay(indxs_dl(1:e,2)));\n%avg_delay(3) = mean(delay(indxs(1:c,3))-delay(indxs_dl(1:f,3)));\navg_delay_m = mean(avg_delay);\n\nmID = max(msgID);\n\navg_delay_m\n\n%% Calculate Package Loss\n\npacket_loss = (1 - ul_packets/dl_packets)*100;\npacket_loss\n\nnode1_pl = (1- a/g)*100;\nnode2_pl = (1- b/h)*100;\n%node3_pl = (1- c/ii)*100;\n\n%% Plot RSSI vs Time\nfigure();\nhold on\n\nline([min(time),max(time)],[avg_rssi(1),avg_rssi(1)], 'Color', [0 0.4470 0.7410], 'LineWidth',lineThickness);\nline([min(time),max(time)],[avg_rssi(2),avg_rssi(2)], 'Color', [0.8500 0.3250 0.0980], 'LineWidth',lineThickness);\n%line([min(time),max(time)],[avg_rssi(3),avg_rssi(3)], 'Color', [0.9290 0.6940 0.1250], 'LineWidth',lineThickness);\n\nscatter(time(indxs(1:a,1)), rssi(indxs(1:a,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],...\n                                                          'MarkerFaceColor',[0 0.4470 0.7410],...\n                                                          'LineWidth',1);\n\nscatter(time(indxs(1:b,2)), rssi(indxs(1:b,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],...\n                                                          'MarkerFaceColor',[0.8500 0.3250 0.0980],...\n                                                          'LineWidth',1);\n\n%scatter(time(indxs(1:c,3)), rssi(indxs(1:c,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],...\n                                                          %'MarkerFaceColor',[0.9290 0.6940 0.1250],...\n                                                          %'LineWidth',1);\n\ngrid on;\nylim([-120 -30]);\nxlim([time(1) time(a+b+c)]);\nxtickformat('mm:ss');\nlegend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1 Packets', 'Node 2 Packets', 'Node 3 Packets','Location','best');\nxlabel(\"Time (mm:ss)\");\nylabel(\"RSSI (dB)\");\n\n\n%% Plot SNR vs Time\nfigure();\nhold on\n\nline([min(time),max(time)],[avg_snr(1),avg_snr(1)], 'Color', [0 0.4470 0.7410]);\nline([min(time),max(time)],[avg_snr(2),avg_snr(2)], 'Color', [0.8500 0.3250 0.0980]);\n%line([min(time),max(time)],[avg_snr(3),avg_snr(3)], 'Color', [0.9290 0.6940 0.1250]);\n\nscatter(time(indxs(1:a,1)), snr(indxs(1:a,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],...\n                                                         'MarkerFaceColor',[0 0.4470 0.7410],...\n                                                         'LineWidth',1);\n\nscatter(time(indxs(1:b,2)), snr(indxs(1:b,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],...\n                                                         'MarkerFaceColor',[0.8500 0.3250 0.0980],...\n                                                         'LineWidth',1);\n\n%scatter(time(indxs(1:c,3)), snr(indxs(1:c,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],...\n                                                         %'MarkerFaceColor',[0.9290 0.6940 0.1250],...\n                                                         %'LineWidth',1);\n\ngrid on;\nylim([-5 13]);\nxlim([time(1) time(a+b+c)]);\nxtickformat('mm:ss');\nlegend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1 Packets', 'Node 2 Packets', 'Node 3 Packets','Location','best');\nxlabel(\"Time (mm:ss)\");\nylabel(\"SNR (dB)\");\n\n\n\n\n%% Plot Delays\n\nfigure();\nhold on\n\nline([min(time),max(time)],[avg_delay(1),avg_delay(1)], 'Color', [0 0.4470 0.7410]);\nline([min(time),max(time)],[avg_delay(2),avg_delay(2)], 'Color', [0.8500 0.3250 0.0980]);\n%line([min(time),max(time)],[avg_delay(3),avg_delay(3)], 'Color', [0.9290 0.6940 0.1250]);\n\nscatter(time(indxs(1:a,1)), delay(indxs(1:a,1))-delay(indxs_dl(1:d,1)),markerSize,'MarkerEdgeColor',[0 0.3470 0.6410],...\n                                                                                  'MarkerFaceColor',[0 0.4470 0.7410],...\n                                                                                  'LineWidth',1);\n\nscatter(time(indxs(1:b,2)), delay(indxs(1:b,2))-delay(indxs_dl(1:e,2)),markerSize,'MarkerEdgeColor',[0.7500 0.2250 0.0680],...\n                                                                                  'MarkerFaceColor',[0.8500 0.3250 0.0980],...\n                                                                                  'LineWidth',1);\n\n%scatter(time(indxs(1:c,3)), delay(indxs(1:c,3))-delay(indxs_dl(1:f,3)),markerSize,'MarkerEdgeColor',[0.8290 0.5940 0.0250],...\n                                                                                  %'MarkerFaceColor',[0.9290 0.6940 0.1250],...\n                                                                                  %'LineWidth',1);\n\ngrid on;\nylim([150 210]);\nxlim([time(1) time(a+b+c)]);\nxtickformat('mm:ss');\nlegend('Node 1 Average', 'Node 2 Average', 'Node 3 Average', 'Node 1', 'Node 2', 'Node 3','Location','best');\nxlabel(\"Time (mm:ss)\");\nylabel(\"Packet Delay (ms)\");\n</code></pre> <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Modules/","title":"Modules","text":"<p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Namespaces/","title":"Namespaces","text":"<ul> <li>namespace network_manager </li> </ul> <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/","title":"network_manager","text":"<p>More...</p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#functions","title":"Functions","text":"Name def network_test()Function that runs a test on the network. def idxFromID(id id) def draw_figure(canvas canvas, figure figure)Function that draws a plot onto a figure. def send_dl_msg(data data)Function that sends a downlink message to the gateway through the serial connection. def export_data(path path)Function to export the gathered data onto a .csv file. def gui()Function responsible for all the GUI initialization and layout. def updateTabs(idx idx)Function that updates the GUI. def serial_comm()Function that handles the received messages from the gateway through the serial communication. def main()Main function."},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#attributes","title":"Attributes","text":"Name int maxNum string gateway_status bool firstTime sc_thread nt_thread"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#detailed-description","title":"Detailed Description","text":"<p>Allows communication with the gateway to monitor and control the network</p> <p>This is a python application with a gui designed to interface with the wireless sensor network through the serial port connected to the gateway. It allows for downlink messages to be sent, uplink messages to be received and monitoring of the network. Additionally, network tests can be run and the data monitored can be exported for further analysis </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-network_test","title":"function network_test","text":"<pre><code>def network_test()\n</code></pre> <p>Function that runs a test on the network. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-idxfromid","title":"function idxFromID","text":"<pre><code>def idxFromID(\n    id id\n)\n</code></pre>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-draw_figure","title":"function draw_figure","text":"<pre><code>def draw_figure(\n    canvas canvas,\n    figure figure\n)\n</code></pre> <p>Function that draws a plot onto a figure. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-send_dl_msg","title":"function send_dl_msg","text":"<pre><code>def send_dl_msg(\n    data data\n)\n</code></pre> <p>Function that sends a downlink message to the gateway through the serial connection. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-export_data","title":"function export_data","text":"<pre><code>def export_data(\n    path path\n)\n</code></pre> <p>Function to export the gathered data onto a .csv file. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-gui","title":"function gui","text":"<pre><code>def gui()\n</code></pre> <p>Function responsible for all the GUI initialization and layout. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-updatetabs","title":"function updateTabs","text":"<pre><code>def updateTabs(\n    idx idx\n)\n</code></pre> <p>Function that updates the GUI. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-serial_comm","title":"function serial_comm","text":"<pre><code>def serial_comm()\n</code></pre> <p>Function that handles the received messages from the gateway through the serial communication. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#function-main","title":"function main","text":"<pre><code>def main()\n</code></pre> <p>Main function. </p>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-maxnum","title":"variable maxNum","text":"<pre><code>int maxNum =  5;\n</code></pre>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-gateway_status","title":"variable gateway_status","text":"<pre><code>string gateway_status =  \"Offline\";\n</code></pre>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-firsttime","title":"variable firstTime","text":"<pre><code>bool firstTime =  True;\n</code></pre>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-sc_thread","title":"variable sc_thread","text":"<pre><code>sc_thread =  threading.Thread(target=serial_comm);\n</code></pre>"},{"location":"Network_Manager/Namespaces/namespacenetwork__manager/#variable-nt_thread","title":"variable nt_thread","text":"<pre><code>nt_thread =  threading.Thread(target=network_test);\n</code></pre> <p>Updated on 2024-02-06 at 12:08:00 +0000</p>"},{"location":"Network_Manager/Pages/","title":"Pages","text":"<p>Updated on 2024-02-06 at 12:08:01 +0000</p>"},{"location":"Node/Classes/","title":"Classes","text":"<ul> <li>struct strMsg Data structure that holds the encrypted payload along with other important fields. </li> <li>struct strPayload Data structure that holds the data for all the fields in the payload. </li> </ul> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Classes/structstr_msg/","title":"strMsg","text":"<p>Data structure that holds the encrypted payload along with other important fields. </p> <p><code>#include &lt;comms_protocol.h&gt;</code></p>"},{"location":"Node/Classes/structstr_msg/#public-attributes","title":"Public Attributes","text":"Name byte msg byte msgID char flag"},{"location":"Node/Classes/structstr_msg/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Node/Classes/structstr_msg/#variable-msg","title":"variable msg","text":"<pre><code>byte msg;\n</code></pre>"},{"location":"Node/Classes/structstr_msg/#variable-msgid","title":"variable msgID","text":"<pre><code>byte msgID;\n</code></pre>"},{"location":"Node/Classes/structstr_msg/#variable-flag","title":"variable flag","text":"<pre><code>char flag;\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Classes/structstr_payload/","title":"strPayload","text":"<p>Data structure that holds the data for all the fields in the payload. </p> <p><code>#include &lt;comms_protocol.h&gt;</code></p>"},{"location":"Node/Classes/structstr_payload/#public-attributes","title":"Public Attributes","text":"Name byte nodeID byte sensorID byte msgID char flag byte sensorVal int RSSI float SNR"},{"location":"Node/Classes/structstr_payload/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"Node/Classes/structstr_payload/#variable-nodeid","title":"variable nodeID","text":"<pre><code>byte nodeID;\n</code></pre>"},{"location":"Node/Classes/structstr_payload/#variable-sensorid","title":"variable sensorID","text":"<pre><code>byte sensorID;\n</code></pre>"},{"location":"Node/Classes/structstr_payload/#variable-msgid","title":"variable msgID","text":"<pre><code>byte msgID;\n</code></pre>"},{"location":"Node/Classes/structstr_payload/#variable-flag","title":"variable flag","text":"<pre><code>char flag;\n</code></pre>"},{"location":"Node/Classes/structstr_payload/#variable-sensorval","title":"variable sensorVal","text":"<pre><code>byte sensorVal;\n</code></pre>"},{"location":"Node/Classes/structstr_payload/#variable-rssi","title":"variable RSSI","text":"<pre><code>int RSSI;\n</code></pre>"},{"location":"Node/Classes/structstr_payload/#variable-snr","title":"variable SNR","text":"<pre><code>float SNR;\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Examples/","title":"Examples","text":"<p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/","title":"Files","text":"<ul> <li>dir /sensor_network/node/node_definitions <ul> <li>file /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. </li> <li>file /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. </li> <li>file /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. </li> <li>file /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. </li> <li>file /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. </li> </ul> </li> <li>file comms_protocol.cpp Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. </li> <li>file comms_protocol.h Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. </li> <li>file node.ino Node script - send sensor data to gateway and receive commands from gateway. </li> <li>file node_definitions.h Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. </li> </ul> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/comms__protocol_8cpp/","title":"comms_protocol.cpp","text":"<p>Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios.  More...</p>"},{"location":"Node/Files/comms__protocol_8cpp/#functions","title":"Functions","text":"Name cppQueue msg_q(sizeof(Msg) , MAX_QUEUE_SIZE , IMPLEMENTATION ) void LoRa_rxMode()Sets the LoRa radio to receive mode. void LoRa_txMode()Sets the LoRa radio to transmit mode. void LoRa_sendMessage(byte * message)Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. byte * encrypt(char msg[MAX_PAYLOAD_SIZE])Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. char * decryptMsg(char msg[MAX_PAYLOAD_SIZE+1])Decrypts a message string using the AES256 algorythm with the corresponding node key. int mymin(int a, int b)returns the minimum value between two integers void sendAck(byte msgID)Send an acknowledge message confirming the reception of an uplink transmission. void sendStatus(byte msgID)Send an uplink message containing the node status. void setActState(int ID, int val)Sets the state of the relevant actuator with the relevant value. void sendSensorData(byte sensorID, byte sensorVal)Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend(unsigned long currentMillis)Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void onReceive(int packetSize)Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary."},{"location":"Node/Files/comms__protocol_8cpp/#attributes","title":"Attributes","text":"Name int currMsg int count unsigned long prevMil unsigned long prevMilSU float VBAT int msgCount aes256_context ctxt"},{"location":"Node/Files/comms__protocol_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Communication Protocol library - set of functions and data structures used to build a network using the LoRa modulation radios. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/comms__protocol_8cpp/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Node/Files/comms__protocol_8cpp/#function-msg_q","title":"function msg_q","text":"<pre><code>cppQueue msg_q(\n    sizeof(Msg) ,\n    MAX_QUEUE_SIZE ,\n    IMPLEMENTATION \n)\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_rxmode","title":"function LoRa_rxMode","text":"<pre><code>void LoRa_rxMode()\n</code></pre> <p>Sets the LoRa radio to receive mode. </p> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_txmode","title":"function LoRa_txMode","text":"<pre><code>void LoRa_txMode()\n</code></pre> <p>Sets the LoRa radio to transmit mode. </p> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-lora_sendmessage","title":"function LoRa_sendMessage","text":"<pre><code>void LoRa_sendMessage(\n    byte * message\n)\n</code></pre> <p>Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. </p> <p>Parameters: </p> <ul> <li>message message to send </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-encrypt","title":"function encrypt","text":"<pre><code>byte * encrypt(\n    char msg[MAX_PAYLOAD_SIZE]\n)\n</code></pre> <p>Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. </p> <p>Parameters: </p> <ul> <li>msg message array to be decrypted </li> </ul> <p>Return: byte* a byte array containing the encrypted message </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-decryptmsg","title":"function decryptMsg","text":"<pre><code>char * decryptMsg(\n    char msg[MAX_PAYLOAD_SIZE+1]\n)\n</code></pre> <p>Decrypts a message string using the AES256 algorythm with the corresponding node key. </p> <p>Parameters: </p> <ul> <li>msg message string to be decrypted </li> </ul> <p>Return: char* an array of characters containing the decrypted message </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-mymin","title":"function mymin","text":"<pre><code>int mymin(\n    int a,\n    int b\n)\n</code></pre> <p>returns the minimum value between two integers </p> <p>Parameters: </p> <ul> <li>a first integer to compare </li> <li>b second integer to compare </li> </ul> <p>Return: int the smaller between a and b </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendack","title":"function sendAck","text":"<pre><code>void sendAck(\n    byte msgID\n)\n</code></pre> <p>Send an acknowledge message confirming the reception of an uplink transmission. </p> <p>Parameters: </p> <ul> <li>msgID ID of the message being acknowledged </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendstatus","title":"function sendStatus","text":"<pre><code>void sendStatus(\n    byte msgID\n)\n</code></pre> <p>Send an uplink message containing the node status. </p> <p>Parameters: </p> <ul> <li>msgID ID of the status request message </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-setactstate","title":"function setActState","text":"<pre><code>void setActState(\n    int ID,\n    int val\n)\n</code></pre> <p>Sets the state of the relevant actuator with the relevant value. </p> <p>Parameters: </p> <ul> <li>ID ID of the relevant actuator </li> <li>val value to which the actuator is set to </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-sendsensordata","title":"function sendSensorData","text":"<pre><code>void sendSensorData(\n    byte sensorID,\n    byte sensorVal\n)\n</code></pre> <p>Adds to the message queue an uplink message containing sensor data. </p> <p>Parameters: </p> <ul> <li>sensorID ID of the relevant sensor </li> <li>sensorVal value read from the relevant sensor </li> </ul> <p>Return: void </p> <p>Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.</p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-getmsgfromqueueandsend","title":"function getMsgFromQueueAndSend","text":"<pre><code>void getMsgFromQueueAndSend(\n    unsigned long currentMillis\n)\n</code></pre> <p>Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. </p> <p>Parameters: </p> <ul> <li>currentMillis current time in millisenconds since boot </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#function-onreceive","title":"function onReceive","text":"<pre><code>void onReceive(\n    int packetSize\n)\n</code></pre> <p>Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. </p> <p>Parameters: </p> <ul> <li>packetSize size of the incoming message in bytes </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8cpp/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/comms__protocol_8cpp/#variable-currmsg","title":"variable currMsg","text":"<pre><code>int currMsg = -1;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#variable-count","title":"variable count","text":"<pre><code>int count = 0;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#variable-prevmil","title":"variable prevMil","text":"<pre><code>unsigned long prevMil;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#variable-prevmilsu","title":"variable prevMilSU","text":"<pre><code>unsigned long prevMilSU;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#variable-vbat","title":"variable VBAT","text":"<pre><code>float VBAT = 1.0;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#variable-msgcount","title":"variable msgCount","text":"<pre><code>int msgCount = 0;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#variable-ctxt","title":"variable ctxt","text":"<pre><code>aes256_context ctxt;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8cpp/#source-code","title":"Source code","text":"<pre><code>\n#include \"comms_protocol.h\"\n\nint currMsg = -1;\nint count = 0;\nunsigned long prevMil;\nunsigned long prevMilSU;\nfloat VBAT = 1.0;\nint msgCount = 0;\n\ncppQueue  msg_q(sizeof(Msg), MAX_QUEUE_SIZE, IMPLEMENTATION);\naes256_context ctxt;\n\nvoid LoRa_rxMode() {\n  LoRa.enableInvertIQ();\n  LoRa.receive();\n}\n\nvoid LoRa_txMode() {\n  LoRa.idle();\n  LoRa.disableInvertIQ();\n}\n\nvoid LoRa_sendMessage(byte *message) {\n  LoRa_txMode();                        // set tx mode\n  LoRa.beginPacket();                   // start packet\n  LoRa.write(netID);\n  LoRa.write(nodeID);\n  //LoRa.print(message);                  // add payload\n  LoRa.write(message, MAX_ENC_PAYLOAD_SIZE);\n  LoRa.endPacket(false);                 // finish packet and send it\n  LoRa_rxMode();\n}\n\nbyte *encrypt(char msg[MAX_PAYLOAD_SIZE]) {\n  String enc = \"\";\n  aes256_init(&amp;ctxt,(uint8_t *) key);\n  const char * p = msg;\n  static byte plain [BLOCK_SIZE];\n  memset (plain, 0, BLOCK_SIZE);  // ensure trailing zeros\n  memcpy (plain, p, mymin (strlen (p), BLOCK_SIZE));\n\n  aes256_encrypt_ecb(&amp;ctxt, plain);\n  return plain;\n  aes256_done(&amp;ctxt);\n}\n\nchar  *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]) {\n  static uint8_t data[MAX_PAYLOAD_SIZE+1];\n  memcpy(data, msg, MAX_PAYLOAD_SIZE+1);\n  //static char m[MAX_PAYLOAD_SIZE+1];\n  //msg.toCharArray(m, MAX_PAYLOAD_SIZE+1);\n  aes256_decrypt_ecb(&amp;ctxt, (uint8_t *)data);\n  return (char *)data;\n}\n\n\nint mymin(int a, int b){\n  if (a&gt;b)\n    return b;\n  return a;\n}\n\n\n\nvoid sendAck(byte msgID) {\n  String enc;\n  char payload[MAX_PAYLOAD_SIZE];\n  char encP[MAX_ENC_PAYLOAD_SIZE];\n  byte l = (byte)MAX_PAYLOAD_SIZE;\n  Msg msg;\n\n  #if defined(ESP32)\n    VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1;\n  #endif\n  int a = VBAT;\n  int b = VBAT*10-a*10;\n  sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 'a', (char)48, (char)48, (char)a+1, (char)b+1);\n\n  //enc = splitAndEncrypt(payload);\n  //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE);\n  byte *plain = encrypt(payload);\n  memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE);\n  msg.msg[MAX_PAYLOAD_SIZE] = '\\0';\n\n  Serial.print(\"add ack to queue: \");\n  Serial.println(payload);\n  //Serial.print(\"enc msg: \");\n  //Serial.println(msg.msg);\n\n  msg.msgID = msgID;\n  msg.flag = 'a';  \n  msg_q.push(&amp;msg);\n}\n\n\nvoid sendStatus(byte msgID) {\n  Msg msg;\n  String enc;\n  char payload[MAX_PAYLOAD_SIZE];\n  msg.msgID = msgID;\n  byte l = (byte) MAX_PAYLOAD_SIZE;\n\n  #if defined(ESP32)\n    VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1;\n  #endif\n  int a = VBAT;\n  int b = VBAT*10-a*10;\n  sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msgID, (char)l, 's', (char)48, (char)48, (char)a+1, (char)b+1);\n\n  //enc = splitAndEncrypt(payload);\n  //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE);\n  byte *plain = encrypt(payload);\n  memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE);\n  msg.msg[MAX_PAYLOAD_SIZE] = '\\0';\n\n  Serial.print(\"add status to queue: \");\n  Serial.println(payload);\n  //Serial.print(\"enc msg: \");\n  //Serial.println(msg.msg);\n\n  // Add msg to msg queue\n  msg.flag = 's';\n  msg_q.push(&amp;msg);\n}\n\nvoid setActState(int ID, int val) {\n  if(ID == 250){\n    switch(val){\n      case 0:\n      LoRa.setSpreadingFactor(7);\n      LoRa.setCodingRate4(5);\n      LoRa.setSignalBandwidth(125E3);\n      break;\n\n      case 1:\n      LoRa.setSpreadingFactor(9);\n      LoRa.setCodingRate4(5);\n      LoRa.setSignalBandwidth(125E3);\n      break;\n\n      case 2:\n      LoRa.setSpreadingFactor(11);\n      LoRa.setCodingRate4(5);\n      LoRa.setSignalBandwidth(125E3);\n      break;\n\n      case 3:\n      LoRa.setSpreadingFactor(7);\n      LoRa.setCodingRate4(5);\n      LoRa.setSignalBandwidth(250E3);\n      break;\n\n      case 4:\n      LoRa.setSpreadingFactor(7);\n      LoRa.setCodingRate4(8);\n      LoRa.setSignalBandwidth(125E3);\n      break;\n    }\n  }else{\n    Serial.print(\"Set actuator: \");\n    Serial.print(ID);\n    Serial.print(\" with value: \");\n    Serial.println(val);\n    digitalWrite(actPin[ID], val);\n  }\n}\n\nvoid sendSensorData(byte sensorID, byte sensorVal) {\n  Msg msg;\n  String enc;\n  char payload[MAX_PAYLOAD_SIZE];\n  msgCount ++;\n  if (msgCount == 0)\n    msgCount ++;\n  msg.msgID = (byte) msgCount;\n  byte l = MAX_PAYLOAD_SIZE;\n\n  #if defined(ESP32)\n    VBAT = (float)(analogRead(vbatPin)) / 4095*2*3.3*1.1;\n  #endif\n  Serial.println(VBAT);\n  int a = VBAT;\n  int b = VBAT*10-a*10;\n  sprintf(payload, \"%c%c%c%c%c%c%c%c\", (char)nodeID, (char)msg.msgID, (char)l, 'u', (char)(sensorID + 1), (char)(sensorVal + 1), (char)a+1, (char)b+1);\n\n  //enc = splitAndEncrypt(payload);\n  //enc.toCharArray(msg.msg, MAX_ENC_PAYLOAD_SIZE);\n  byte *plain = encrypt(payload);\n  memcpy(msg.msg, plain, MAX_PAYLOAD_SIZE);\n  msg.msg[MAX_PAYLOAD_SIZE] = '\\0';\n\n  // Add msg to msg queue\n  msg.flag = 'u';\n  msg_q.push(&amp;msg);\n}\n\nvoid getMsgFromQueueAndSend(unsigned long currentMillis) {\n  if (!msg_q.isEmpty()) {\n    Msg msg;\n    msg_q.peek(&amp;msg);\n\n    if (currMsg == msg.msgID)\n      count ++;\n    else\n      count = 0;\n\n    currMsg = msg.msgID;\n    if (count &lt; MAX_N_RETRY) {\n      Serial.print(\"send msg: \");\n      //Serial.println(msg.msg);\n      LoRa_sendMessage(msg.msg);\n      if ((msg.flag == 's') || (msg.flag == 'a')){\n        msg_q.drop();\n        currMsg = -1;\n      }\n    } else {\n      Serial.print(\"Failed to send msg with id: \");\n      Serial.println(msg.msgID);\n      msg_q.drop();\n      currMsg = -1;\n    }\n    prevMil = currentMillis;\n  }\n}\n\nvoid onReceive(int packetSize){\n  byte rNetID = LoRa.read();\n  byte rnID = LoRa.read();\n  char buffer1[MAX_ENC_PAYLOAD_SIZE];\n  char buffer2[MAX_ENC_PAYLOAD_SIZE];\n  String message = \"\";\n  int i=0;\n  while (LoRa.available() &amp;&amp; i&lt;MAX_ENC_PAYLOAD_SIZE) {\n    //Serial.println(LoRa.peek(), HEX);\n    buffer1[i] = (char)LoRa.read();\n    //message += (char)LoRa.read();\n\n    i++;\n  }\n  Serial.println(\"msg\");\n  //Serial.println(message.length());\n  //Serial.println(MAX_ENC_PAYLOAD_SIZE);\n  //Serial.println(rNetID == netID);\n  if (rNetID == netID) {\n    Serial.println(\"New msg received\");\n\n\n    //int j = message.length() / ENC_BLOCK_SIZE;\n    //int h = message.length() / (1 * j);\n\n    byte len;\n    Payload p;\n\n    if (rnID == BROADCAST_ID)\n      aes256_init(&amp;ctxt,(uint8_t *) keyBroadcast);\n    else\n      aes256_init(&amp;ctxt,(uint8_t *) key);\n    //for (int i = 0; i &lt; j; i++) {\n    //  if (i == 0)\n    //    strcpy(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE)));\n    //  else\n    //    strcat(buffer1, decryptMsg(message.substring(i * ENC_BLOCK_SIZE, (i + 1) * ENC_BLOCK_SIZE)));\n    //}\n    strcpy(buffer2, decryptMsg(buffer1));\n    aes256_done(&amp;ctxt);\n\n    buffer2[6] = '\\0';\n\n    Serial.println(buffer2);\n    if(sscanf(buffer2, \"%c%c%c%c%c%c\", &amp;p.nodeID, &amp;p.msgID, &amp;len, &amp;p.flag, &amp;p.sensorID, &amp;p.sensorVal) == 6){\n      Serial.println(p.flag);\n      Msg msg;\n      msg_q.peek(&amp;msg);\n      if (p.nodeID == nodeID || p.nodeID == BROADCAST_ID) {\n        Serial.println(\"rssi,snr\");\n        Serial.println(LoRa.packetRssi());\n        Serial.println(LoRa.packetSnr());\n        if (p.flag == 'a') {\n          if (p.msgID == msg.msgID) {\n            Serial.print(\"Message with ID: \");\n            Serial.print(p.msgID);\n            Serial.println(\" delivered!\");\n            msg_q.drop();\n          }\n        } else if (p.flag == 's') {\n          Serial.print(\"received msg with id: \");\n          Serial.println(p.msgID);\n          sendStatus(p.msgID);\n        } else if (p.flag == 'c') {\n          // Set actuator value and send ack\n          setActState((int)(p.sensorID - 1), (int)(p.sensorVal - 1));\n          sendAck(p.msgID);\n        }\n      }\n    }  \n  }\n}\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/comms__protocol_8h/","title":"comms_protocol.h","text":"<p>Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library.  More...</p>"},{"location":"Node/Files/comms__protocol_8h/#classes","title":"Classes","text":"Name struct strPayload Data structure that holds the data for all the fields in the payload. struct strMsg Data structure that holds the encrypted payload along with other important fields."},{"location":"Node/Files/comms__protocol_8h/#types","title":"Types","text":"Name typedef struct strPayload Payload Data structure that holds the data for all the fields in the payload. typedef struct strMsg Msg Data structure that holds the encrypted payload along with other important fields."},{"location":"Node/Files/comms__protocol_8h/#functions","title":"Functions","text":"Name void LoRa_rxMode()Sets the LoRa radio to receive mode. void LoRa_txMode()Sets the LoRa radio to transmit mode. void LoRa_sendMessage(byte * message)Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. char * decryptMsg(char msg[MAX_PAYLOAD_SIZE+1])Decrypts a message string using the AES256 algorythm with the corresponding node key. void onReceive(int packetSize)Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. void onTxDone() byte * encrypt(char msg[MAX_PAYLOAD_SIZE])Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. void sendSensorData(byte sensorID, byte sensorVal)Adds to the message queue an uplink message containing sensor data. void getMsgFromQueueAndSend(unsigned long currentMillis)Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. void sendStatus(byte msgID)Send an uplink message containing the node status. void sendAck(byte msgID)Send an acknowledge message confirming the reception of an uplink transmission. void setActState(int ID, int val)Sets the state of the relevant actuator with the relevant value. int mymin(int a, int b)returns the minimum value between two integers"},{"location":"Node/Files/comms__protocol_8h/#attributes","title":"Attributes","text":"Name const uint8_t keyBroadcast const long frequency const int txPower const int spreadingFactor const long signalBandwidth const int codingRateDenominator int currMsg int count unsigned long prevMil unsigned long prevMilSU int msgCount cppQueue msg_q aes256_context ctxt"},{"location":"Node/Files/comms__protocol_8h/#defines","title":"Defines","text":"Name IMPLEMENTATION MAX_N_RETRY TIMEOUT_INTERVAL MAX_QUEUE_SIZE BLOCK_SIZE MAX_PAYLOAD_SIZE ENC_BLOCK_SIZE MAX_ENC_PAYLOAD_SIZE MAX_MSG_ID STATUS_UPDATE_INTERVAL BROADCAST_ID"},{"location":"Node/Files/comms__protocol_8h/#detailed-description","title":"Detailed Description","text":"<p>Header file for the communication protocol library. Contains the used data structures, function declaration and general configuartion options for the library. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/comms__protocol_8h/#types-documentation","title":"Types Documentation","text":""},{"location":"Node/Files/comms__protocol_8h/#typedef-payload","title":"typedef Payload","text":"<pre><code>typedef struct strPayload Payload;\n</code></pre> <p>Data structure that holds the data for all the fields in the payload. </p>"},{"location":"Node/Files/comms__protocol_8h/#typedef-msg","title":"typedef Msg","text":"<pre><code>typedef struct strMsg Msg;\n</code></pre> <p>Data structure that holds the encrypted payload along with other important fields. </p>"},{"location":"Node/Files/comms__protocol_8h/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Node/Files/comms__protocol_8h/#function-lora_rxmode","title":"function LoRa_rxMode","text":"<pre><code>void LoRa_rxMode()\n</code></pre> <p>Sets the LoRa radio to receive mode. </p> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-lora_txmode","title":"function LoRa_txMode","text":"<pre><code>void LoRa_txMode()\n</code></pre> <p>Sets the LoRa radio to transmit mode. </p> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-lora_sendmessage","title":"function LoRa_sendMessage","text":"<pre><code>void LoRa_sendMessage(\n    byte * message\n)\n</code></pre> <p>Sets the radio to transmit mode, sends a message string using the LoRa radio and sets the radio back to receive mode. </p> <p>Parameters: </p> <ul> <li>message message to send </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-decryptmsg","title":"function decryptMsg","text":"<pre><code>char * decryptMsg(\n    char msg[MAX_PAYLOAD_SIZE+1]\n)\n</code></pre> <p>Decrypts a message string using the AES256 algorythm with the corresponding node key. </p> <p>Parameters: </p> <ul> <li>msg message string to be decrypted </li> </ul> <p>Return: char* an array of characters containing the decrypted message </p>"},{"location":"Node/Files/comms__protocol_8h/#function-onreceive","title":"function onReceive","text":"<pre><code>void onReceive(\n    int packetSize\n)\n</code></pre> <p>Called every time a new message is received. Filters unwanted messages, decrypts the payload, gets the relevant fields from the payload and sends back an acknowledge message if necessary. </p> <p>Parameters: </p> <ul> <li>packetSize size of the incoming message in bytes </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-ontxdone","title":"function onTxDone","text":"<pre><code>void onTxDone()\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#function-encrypt","title":"function encrypt","text":"<pre><code>byte * encrypt(\n    char msg[MAX_PAYLOAD_SIZE]\n)\n</code></pre> <p>Encrypts a message (character array) using the AES256 algorythm with the corresponding node key The encryption is made by encrypting blocks of 16 bytes and joining them together. </p> <p>Parameters: </p> <ul> <li>msg message array to be decrypted </li> </ul> <p>Return: byte* a byte array containing the encrypted message </p>"},{"location":"Node/Files/comms__protocol_8h/#function-sendsensordata","title":"function sendSensorData","text":"<pre><code>void sendSensorData(\n    byte sensorID,\n    byte sensorVal\n)\n</code></pre> <p>Adds to the message queue an uplink message containing sensor data. </p> <p>Parameters: </p> <ul> <li>sensorID ID of the relevant sensor </li> <li>sensorVal value read from the relevant sensor </li> </ul> <p>Return: void </p> <p>Note: The ADC value is a 12-bit number, so the maximum value is 4095 (counting from 0). To convert the ADC integer value to a real voltage you\u2019ll need to divide it by the maximum value of 4095, then double it (note above that Adafruit halves the voltage), then multiply that by the reference voltage of the ESP32 which is 3.3V and then vinally, multiply that again by the ADC Reference Voltage of 1100mV.</p>"},{"location":"Node/Files/comms__protocol_8h/#function-getmsgfromqueueandsend","title":"function getMsgFromQueueAndSend","text":"<pre><code>void getMsgFromQueueAndSend(\n    unsigned long currentMillis\n)\n</code></pre> <p>Get a message from the send queue and send it. Implements retransmission in case an acknowledge message is not received. Aware of a failed transmission. </p> <p>Parameters: </p> <ul> <li>currentMillis current time in millisenconds since boot </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-sendstatus","title":"function sendStatus","text":"<pre><code>void sendStatus(\n    byte msgID\n)\n</code></pre> <p>Send an uplink message containing the node status. </p> <p>Parameters: </p> <ul> <li>msgID ID of the status request message </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-sendack","title":"function sendAck","text":"<pre><code>void sendAck(\n    byte msgID\n)\n</code></pre> <p>Send an acknowledge message confirming the reception of an uplink transmission. </p> <p>Parameters: </p> <ul> <li>msgID ID of the message being acknowledged </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-setactstate","title":"function setActState","text":"<pre><code>void setActState(\n    int ID,\n    int val\n)\n</code></pre> <p>Sets the state of the relevant actuator with the relevant value. </p> <p>Parameters: </p> <ul> <li>ID ID of the relevant actuator </li> <li>val value to which the actuator is set to </li> </ul> <p>Return: void </p>"},{"location":"Node/Files/comms__protocol_8h/#function-mymin","title":"function mymin","text":"<pre><code>int mymin(\n    int a,\n    int b\n)\n</code></pre> <p>returns the minimum value between two integers </p> <p>Parameters: </p> <ul> <li>a first integer to compare </li> <li>b second integer to compare </li> </ul> <p>Return: int the smaller between a and b </p>"},{"location":"Node/Files/comms__protocol_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/comms__protocol_8h/#variable-keybroadcast","title":"variable keyBroadcast","text":"<pre><code>const uint8_t keyBroadcast = { \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f\n};\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-frequency","title":"variable frequency","text":"<pre><code>const long frequency = 868E6;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-txpower","title":"variable txPower","text":"<pre><code>const int txPower = 14;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-spreadingfactor","title":"variable spreadingFactor","text":"<pre><code>const int spreadingFactor = 7;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-signalbandwidth","title":"variable signalBandwidth","text":"<pre><code>const long signalBandwidth = 125E3;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-codingratedenominator","title":"variable codingRateDenominator","text":"<pre><code>const int codingRateDenominator = 5;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-currmsg","title":"variable currMsg","text":"<pre><code>int currMsg;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-count","title":"variable count","text":"<pre><code>int count;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-prevmil","title":"variable prevMil","text":"<pre><code>unsigned long prevMil;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-prevmilsu","title":"variable prevMilSU","text":"<pre><code>unsigned long prevMilSU;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-msgcount","title":"variable msgCount","text":"<pre><code>int msgCount;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-msg_q","title":"variable msg_q","text":"<pre><code>cppQueue msg_q;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#variable-ctxt","title":"variable ctxt","text":"<pre><code>aes256_context ctxt;\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/comms__protocol_8h/#define-implementation","title":"define IMPLEMENTATION","text":"<pre><code>#define IMPLEMENTATION FIFO\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-max_n_retry","title":"define MAX_N_RETRY","text":"<pre><code>#define MAX_N_RETRY 3\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-timeout_interval","title":"define TIMEOUT_INTERVAL","text":"<pre><code>#define TIMEOUT_INTERVAL 6000\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-max_queue_size","title":"define MAX_QUEUE_SIZE","text":"<pre><code>#define MAX_QUEUE_SIZE 5\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-block_size","title":"define BLOCK_SIZE","text":"<pre><code>#define BLOCK_SIZE 16\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-max_payload_size","title":"define MAX_PAYLOAD_SIZE","text":"<pre><code>#define MAX_PAYLOAD_SIZE 16\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-enc_block_size","title":"define ENC_BLOCK_SIZE","text":"<pre><code>#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-max_enc_payload_size","title":"define MAX_ENC_PAYLOAD_SIZE","text":"<pre><code>#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-max_msg_id","title":"define MAX_MSG_ID","text":"<pre><code>#define MAX_MSG_ID 256\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-status_update_interval","title":"define STATUS_UPDATE_INTERVAL","text":"<pre><code>#define STATUS_UPDATE_INTERVAL 60000\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#define-broadcast_id","title":"define BROADCAST_ID","text":"<pre><code>#define BROADCAST_ID 0xFF\n</code></pre>"},{"location":"Node/Files/comms__protocol_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef COMMS_PROTOCOL_H\n#define COMMS_PROTOCOL_H\n\n#include &lt;Arduino.h&gt;\n#include &lt;SPI.h&gt;              \n#include &lt;LoRa.h&gt;\n#include &lt;cppQueue.h&gt;\n#include &lt;aes256.h&gt;\n#include \"node_definitions.h\"\n\n#define  IMPLEMENTATION  FIFO\n\n// LoRa msg payload settings\n#define MAX_N_RETRY 3\n#define TIMEOUT_INTERVAL 6000\n#define MAX_QUEUE_SIZE 5\n\n#define BLOCK_SIZE 16\n#define MAX_PAYLOAD_SIZE 16\n#define ENC_BLOCK_SIZE (1*BLOCK_SIZE)\n#define MAX_ENC_PAYLOAD_SIZE ((MAX_PAYLOAD_SIZE/BLOCK_SIZE)*ENC_BLOCK_SIZE)+1\n\n#define MAX_MSG_ID 256\n\n#define STATUS_UPDATE_INTERVAL 60000\n\n#define BROADCAST_ID 0xFF\n\n// Broadcast Encryption key\nconst uint8_t keyBroadcast[] = { //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f\n};\n\n\n\n// LoRa Modem Settings\nconst long frequency = 868E6;\nconst int txPower = 14;\nconst int spreadingFactor = 7;\nconst long signalBandwidth = 125E3;\nconst int codingRateDenominator = 5;\n\ntypedef struct strPayload {\n  byte nodeID;\n  byte sensorID;\n  byte msgID;\n  char flag;\n  byte sensorVal;\n  int RSSI;\n  float SNR;\n} Payload;\n\ntypedef struct strMsg {\n  byte msg[MAX_ENC_PAYLOAD_SIZE];\n  byte msgID;\n  char flag;\n} Msg;\n\nextern int currMsg;\nextern int count;\nextern unsigned long prevMil;\nextern unsigned long prevMilSU;\nextern int msgCount;\n\nextern cppQueue msg_q;\nextern aes256_context ctxt;\n\nvoid LoRa_rxMode();\nvoid LoRa_txMode();\nvoid LoRa_sendMessage(byte *message);\nchar  *decryptMsg(char msg[MAX_PAYLOAD_SIZE+1]);\nvoid onReceive(int packetSize);\nvoid onTxDone();\nbyte *encrypt(char msg[MAX_PAYLOAD_SIZE]);\nvoid sendSensorData(byte sensorID, byte sensorVal);\nvoid getMsgFromQueueAndSend(unsigned long currentMillis);\nvoid sendStatus(byte msgID);\nvoid sendAck(byte msgID);\nvoid setActState(int ID, int val);\nint mymin(int a, int b);\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/","title":"/sensor_network/node/node_definitions","text":""},{"location":"Node/Files/dir_bbe80895da9089dc2b343d9c86835d12/#files","title":"Files","text":"Name /sensor_network/node/node_definitions/node_definitions_1.h Definitions for node with id 1. /sensor_network/node/node_definitions/node_definitions_2.h Definitions for node with id 2. /sensor_network/node/node_definitions/node_definitions_3.h Definitions for node with id 3. /sensor_network/node/node_definitions/node_definitions_4.h Definitions for node with id 4. /sensor_network/node/node_definitions/node_definitions_uno.h Definitions for node with id 1. <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node_8ino/","title":"node.ino","text":"<p>Node script - send sensor data to gateway and receive commands from gateway.  More...</p>"},{"location":"Node/Files/node_8ino/#functions","title":"Functions","text":"Name void setup()Arduino setup function. void loop()Arduino loop function."},{"location":"Node/Files/node_8ino/#attributes","title":"Attributes","text":"Name int motionState long t1 long t2"},{"location":"Node/Files/node_8ino/#detailed-description","title":"Detailed Description","text":"<p>Node script - send sensor data to gateway and receive commands from gateway. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-09</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node_8ino/#functions-documentation","title":"Functions Documentation","text":""},{"location":"Node/Files/node_8ino/#function-setup","title":"function setup","text":"<pre><code>void setup()\n</code></pre> <p>Arduino setup function. </p> <p>Return: void </p> <p>Runs once at boot. Configure the serial communication. Configure the LoRa radio. Configure the sensors and actuators input mode</p>"},{"location":"Node/Files/node_8ino/#function-loop","title":"function loop","text":"<pre><code>void loop()\n</code></pre> <p>Arduino loop function. </p> <p>Return: void </p> <p>Main loop function. checks for incoming uplink messages and downlink requests from the server. calls getMsgFromQueueAndSend on fixed schedules to avoid congestion of the communication channel and sends an uplink message with the node status periodically.</p>"},{"location":"Node/Files/node_8ino/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node_8ino/#variable-motionstate","title":"variable motionState","text":"<pre><code>int motionState = 0;\n</code></pre>"},{"location":"Node/Files/node_8ino/#variable-t1","title":"variable t1","text":"<pre><code>long t1;\n</code></pre>"},{"location":"Node/Files/node_8ino/#variable-t2","title":"variable t2","text":"<pre><code>long t2;\n</code></pre>"},{"location":"Node/Files/node_8ino/#source-code","title":"Source code","text":"<pre><code>\n#include \"comms_protocol.h\"\nint motionState = 0;\nlong t1;\nlong t2;\n\nvoid setup() {\n  for(int i=0; i&lt;sensN; i++){\n    pinMode(sensPin[i], INPUT); \n  }\n  for(int i=0; i&lt;actN; i++){\n    pinMode(actPin[i], OUTPUT); \n  }\n  Serial.begin(BAUD_RATE);\n\n  #if defined(ESP32)\n    SPI.begin(SCK, MISO, MOSI, SS);\n  #endif  \n  LoRa.setPins(SS, RST, DIO0);\n\n  if (!LoRa.begin(frequency)) {\n    Serial.println(\"LoRa init failed.\");\n    while (true);\n  }\n\n  LoRa.setSpreadingFactor(spreadingFactor);\n  LoRa.setCodingRate4(codingRateDenominator);\n  LoRa.setSignalBandwidth(signalBandwidth);\n\n  LoRa.setSyncWord(netID);\n  LoRa.enableCrc();\n  LoRa_rxMode();\n\n  prevMil = millis();\n  prevMilSU = millis();\n\n  Serial.println(\"Node startup complete\");\n}\n\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n\n  // Receive Downlink msg\n  int packetSize = LoRa.parsePacket();\n  if (packetSize) {\n    onReceive(packetSize);\n  }\n\n  // Send Uplink msg\n  if((currentMillis-prevMil) &gt; TIMEOUT_INTERVAL){\n    getMsgFromQueueAndSend(currentMillis);\n  }\n\n  // Send node status\n  if((currentMillis-prevMilSU) &gt; STATUS_UPDATE_INTERVAL){\n    byte msgID = random(MAX_MSG_ID);\n    //sendStatus(msgID);\n    prevMilSU = currentMillis;\n  }\n\n  // Send sensor data\n  if(millis() &gt; 30000){\n    int val = digitalRead(sensPin[0]);\n    if((val == 1) &amp;&amp; (motionState == 0)){\n      Serial.println(\"motion detected\");\n      sendSensorData(0, 1);\n      t1 = millis();\n    }\n    motionState = val;\n  }\n\n\n}\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node__definitions_8h/","title":"node_definitions.h","text":"<p>Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings.  More...</p>"},{"location":"Node/Files/node__definitions_8h/#attributes","title":"Attributes","text":"Name const byte netID const int sensN const int actN"},{"location":"Node/Files/node__definitions_8h/#defines","title":"Defines","text":"Name BAUD_RATE"},{"location":"Node/Files/node__definitions_8h/#detailed-description","title":"Detailed Description","text":"<p>Header file for the node program. Contains hardware pinouts, LoRa modem configs and node settings. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node__definitions_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node__definitions_8h/#variable-netid","title":"variable netID","text":"<pre><code>const byte netID = 0xF3;\n</code></pre>"},{"location":"Node/Files/node__definitions_8h/#variable-sensn","title":"variable sensN","text":"<pre><code>const int sensN = sizeof(sensPin)/sizeof(int);\n</code></pre>"},{"location":"Node/Files/node__definitions_8h/#variable-actn","title":"variable actN","text":"<pre><code>const int actN = sizeof(actPin)/sizeof(int);\n</code></pre>"},{"location":"Node/Files/node__definitions_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/node__definitions_8h/#define-baud_rate","title":"define BAUD_RATE","text":"<pre><code>#define BAUD_RATE 115200\n</code></pre>"},{"location":"Node/Files/node__definitions_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef NODE_DEFINITIONS_H\n#define NODE_DEFINITIONS_H\n\n// Baud rate for serial communication\n#define BAUD_RATE 115200\n\n// Node Settings\nconst byte netID = 0xF3;\n\n#include \"node_definitions/node_definitions_1.h\"\n\nconst int sensN = sizeof(sensPin)/sizeof(int);\nconst int actN = sizeof(actPin)/sizeof(int);\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node__definitions__1_8h/","title":"/sensor_network/node/node_definitions/node_definitions_1.h","text":"<p>Definitions for node with id 1.  More...</p>"},{"location":"Node/Files/node__definitions__1_8h/#attributes","title":"Attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin"},{"location":"Node/Files/node__definitions__1_8h/#defines","title":"Defines","text":"Name SCK MISO MOSI SS RST DIO0"},{"location":"Node/Files/node__definitions__1_8h/#detailed-description","title":"Detailed Description","text":"<p>Definitions for node with id 1. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node__definitions__1_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node__definitions__1_8h/#variable-key","title":"variable key","text":"<pre><code>const uint8_t key = { \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n};\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#variable-nodeid","title":"variable nodeID","text":"<pre><code>const byte nodeID = 0x01;\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#variable-vbatpin","title":"variable vbatPin","text":"<pre><code>const int vbatPin = 35;\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#variable-senspin","title":"variable sensPin","text":"<pre><code>const int sensPin = {16};\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#variable-actpin","title":"variable actPin","text":"<pre><code>const int actPin = {LED_BUILTIN};\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/node__definitions__1_8h/#define-sck","title":"define SCK","text":"<pre><code>#define SCK 5\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#define-miso","title":"define MISO","text":"<pre><code>#define MISO 19\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#define-mosi","title":"define MOSI","text":"<pre><code>#define MOSI 27\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#define-ss","title":"define SS","text":"<pre><code>#define SS 18\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#define-rst","title":"define RST","text":"<pre><code>#define RST 14\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#define-dio0","title":"define DIO0","text":"<pre><code>#define DIO0 26\n</code></pre>"},{"location":"Node/Files/node__definitions__1_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef NODE_DEFINITIONS_1_H\n#define NODE_DEFINITIONS_1_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n};\n\n// SPI pinout for TTGO boards\n#define SCK 5\n#define MISO 19\n#define MOSI 27\n\n// LoRa Modem Pinout for TTGO boards\n#define SS 18\n#define RST 14\n#define DIO0 26\n\n// Node Settings\nconst byte nodeID = 0x01;\n\n// Node I/O Pinout\nconst int vbatPin = 35;\n\nconst int sensPin[] = {16};\nconst int actPin[] = {LED_BUILTIN};\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node__definitions__2_8h/","title":"/sensor_network/node/node_definitions/node_definitions_2.h","text":"<p>Definitions for node with id 2.  More...</p>"},{"location":"Node/Files/node__definitions__2_8h/#attributes","title":"Attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin"},{"location":"Node/Files/node__definitions__2_8h/#defines","title":"Defines","text":"Name SCK MISO MOSI SS RST DIO0"},{"location":"Node/Files/node__definitions__2_8h/#detailed-description","title":"Detailed Description","text":"<p>Definitions for node with id 2. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node__definitions__2_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node__definitions__2_8h/#variable-key","title":"variable key","text":"<pre><code>const uint8_t key = { \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f\n};\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#variable-nodeid","title":"variable nodeID","text":"<pre><code>const byte nodeID = 0x02;\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#variable-vbatpin","title":"variable vbatPin","text":"<pre><code>const int vbatPin = 35;\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#variable-senspin","title":"variable sensPin","text":"<pre><code>const int sensPin = {16};\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#variable-actpin","title":"variable actPin","text":"<pre><code>const int actPin = {LED_BUILTIN};\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/node__definitions__2_8h/#define-sck","title":"define SCK","text":"<pre><code>#define SCK 5\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#define-miso","title":"define MISO","text":"<pre><code>#define MISO 19\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#define-mosi","title":"define MOSI","text":"<pre><code>#define MOSI 27\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#define-ss","title":"define SS","text":"<pre><code>#define SS 18\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#define-rst","title":"define RST","text":"<pre><code>#define RST 14\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#define-dio0","title":"define DIO0","text":"<pre><code>#define DIO0 26\n</code></pre>"},{"location":"Node/Files/node__definitions__2_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef NODE_DEFINITIONS_2_H\n#define NODE_DEFINITIONS_2_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f\n};\n\n// SPI pinout for TTGO boards\n#define SCK 5\n#define MISO 19\n#define MOSI 27\n\n// LoRa Modem Pinout for TTGO boards\n#define SS 18\n#define RST 14\n#define DIO0 26\n\n// Node Settings\nconst byte nodeID = 0x02;\n\n// Node I/O Pinout\nconst int vbatPin = 35;\n\nconst int sensPin[] = {16};\nconst int actPin[] = {LED_BUILTIN};\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node__definitions__3_8h/","title":"/sensor_network/node/node_definitions/node_definitions_3.h","text":"<p>Definitions for node with id 3.  More...</p>"},{"location":"Node/Files/node__definitions__3_8h/#attributes","title":"Attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin"},{"location":"Node/Files/node__definitions__3_8h/#defines","title":"Defines","text":"Name SCK MISO MOSI SS RST DIO0"},{"location":"Node/Files/node__definitions__3_8h/#detailed-description","title":"Detailed Description","text":"<p>Definitions for node with id 3. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node__definitions__3_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node__definitions__3_8h/#variable-key","title":"variable key","text":"<pre><code>const uint8_t key = { \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f\n};\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#variable-nodeid","title":"variable nodeID","text":"<pre><code>const byte nodeID = 0x03;\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#variable-vbatpin","title":"variable vbatPin","text":"<pre><code>const int vbatPin = 35;\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#variable-senspin","title":"variable sensPin","text":"<pre><code>const int sensPin = {16};\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#variable-actpin","title":"variable actPin","text":"<pre><code>const int actPin = {LED_BUILTIN};\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/node__definitions__3_8h/#define-sck","title":"define SCK","text":"<pre><code>#define SCK 5\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#define-miso","title":"define MISO","text":"<pre><code>#define MISO 19\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#define-mosi","title":"define MOSI","text":"<pre><code>#define MOSI 27\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#define-ss","title":"define SS","text":"<pre><code>#define SS 18\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#define-rst","title":"define RST","text":"<pre><code>#define RST 14\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#define-dio0","title":"define DIO0","text":"<pre><code>#define DIO0 26\n</code></pre>"},{"location":"Node/Files/node__definitions__3_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef NODE_DEFINITIONS_3_H\n#define NODE_DEFINITIONS_3_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x3f\n};\n\n// SPI pinout for TTGO boards\n#define SCK 5\n#define MISO 19\n#define MOSI 27\n\n// LoRa Modem Pinout for TTGO boards\n#define SS 18\n#define RST 14\n#define DIO0 26\n\n// Node Settings\nconst byte nodeID = 0x03;\n\n// Node I/O Pinout\nconst int vbatPin = 35;\n\nconst int sensPin[] = {16};\nconst int actPin[] = {LED_BUILTIN};\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node__definitions__4_8h/","title":"/sensor_network/node/node_definitions/node_definitions_4.h","text":"<p>Definitions for node with id 4.  More...</p>"},{"location":"Node/Files/node__definitions__4_8h/#attributes","title":"Attributes","text":"Name const uint8_t key const byte nodeID const int vbatPin const int sensPin const int actPin"},{"location":"Node/Files/node__definitions__4_8h/#defines","title":"Defines","text":"Name SCK MISO MOSI SS RST DIO0"},{"location":"Node/Files/node__definitions__4_8h/#detailed-description","title":"Detailed Description","text":"<p>Definitions for node with id 4. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node__definitions__4_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node__definitions__4_8h/#variable-key","title":"variable key","text":"<pre><code>const uint8_t key = { \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f\n};\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#variable-nodeid","title":"variable nodeID","text":"<pre><code>const byte nodeID = 0x04;\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#variable-vbatpin","title":"variable vbatPin","text":"<pre><code>const int vbatPin = 35;\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#variable-senspin","title":"variable sensPin","text":"<pre><code>const int sensPin = {16};\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#variable-actpin","title":"variable actPin","text":"<pre><code>const int actPin = {LED_BUILTIN};\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/node__definitions__4_8h/#define-sck","title":"define SCK","text":"<pre><code>#define SCK 5\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#define-miso","title":"define MISO","text":"<pre><code>#define MISO 19\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#define-mosi","title":"define MOSI","text":"<pre><code>#define MOSI 27\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#define-ss","title":"define SS","text":"<pre><code>#define SS 18\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#define-rst","title":"define RST","text":"<pre><code>#define RST 14\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#define-dio0","title":"define DIO0","text":"<pre><code>#define DIO0 26\n</code></pre>"},{"location":"Node/Files/node__definitions__4_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef NODE_DEFINITIONS_4_H\n#define NODE_DEFINITIONS_4_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x4f\n};\n\n// SPI pinout for TTGO boards\n#define SCK 5\n#define MISO 19\n#define MOSI 27\n\n// LoRa Modem Pinout for TTGO boards\n#define SS 18\n#define RST 14\n#define DIO0 26\n\n// Node Settings\nconst byte nodeID = 0x04;\n\n// Node I/O Pinout\nconst int vbatPin = 35;\n\nconst int sensPin[] = {16};\nconst int actPin[] = {LED_BUILTIN};\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Files/node__definitions__uno_8h/","title":"/sensor_network/node/node_definitions/node_definitions_uno.h","text":"<p>Definitions for node with id 1.  More...</p>"},{"location":"Node/Files/node__definitions__uno_8h/#attributes","title":"Attributes","text":"Name const uint8_t key const byte nodeID const int sensPin const int actPin"},{"location":"Node/Files/node__definitions__uno_8h/#defines","title":"Defines","text":"Name SS RST DIO0"},{"location":"Node/Files/node__definitions__uno_8h/#detailed-description","title":"Detailed Description","text":"<p>Definitions for node with id 1. </p> <p>Author: Francisco Santos (francisco.velez@tecnico.ulisboa.pt) </p> <p>Version: 1.0 </p> <p>Date: 2022-08-10</p> <p>Copyright: Copyright (c) 2022 </p>"},{"location":"Node/Files/node__definitions__uno_8h/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"Node/Files/node__definitions__uno_8h/#variable-key","title":"variable key","text":"<pre><code>const uint8_t key = { \n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n};\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#variable-nodeid","title":"variable nodeID","text":"<pre><code>const byte nodeID = 0x01;\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#variable-senspin","title":"variable sensPin","text":"<pre><code>const int sensPin = {};\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#variable-actpin","title":"variable actPin","text":"<pre><code>const int actPin = {4};\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#macros-documentation","title":"Macros Documentation","text":""},{"location":"Node/Files/node__definitions__uno_8h/#define-ss","title":"define SS","text":"<pre><code>#define SS 10\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#define-rst","title":"define RST","text":"<pre><code>#define RST 9\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#define-dio0","title":"define DIO0","text":"<pre><code>#define DIO0 2\n</code></pre>"},{"location":"Node/Files/node__definitions__uno_8h/#source-code","title":"Source code","text":"<pre><code>\n#ifndef NODE_DEFINITIONS_1_H\n#define NODE_DEFINITIONS_1_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n};\n\n// LoRa Modem Pinout for boards with the Dragino LoRa shield\n#define SS 10\n#define RST 9\n#define DIO0 2\n\n// Node Settings\nconst byte nodeID = 0x01;\n\n// Node I/O Pinout\n\nconst int sensPin[] = {};\nconst int actPin[] = {4};\n\n#endif\n</code></pre> <p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Modules/","title":"Modules","text":"<p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Namespaces/","title":"Namespaces","text":"<p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"Node/Pages/","title":"Pages","text":"<p>Updated on 2024-02-06 at 12:07:55 +0000</p>"},{"location":"pages/example_usage/","title":"Example Usage","text":"<p>As an example, a network was set-up with 2 node devices. The Arduino uno with the SX1276 Dragino shield was used as the hardware platform for the gateway and the TTGO LoRa ESP32 modules were used for the node devices. Regarding sensors and actuators, a motion sensor was attached to each of the nodes and the builtin LED was used as an actuator.</p> <p><code>node_definitions_1.h</code> file:</p> <pre><code>#ifndef NODE_DEFINITIONS_1_H\n#define NODE_DEFINITIONS_1_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n};\n\n// SPI pinout for TTGO boards\n#define SCK 5\n#define MISO 19\n#define MOSI 27\n\n// LoRa Modem Pinout for TTGO boards\n#define SS 18\n#define RST 14\n#define DIO0 26\n\n// Node Settings\nconst byte nodeID = 0x01;\n\n// Node I/O Pinout\nconst int vbatPin = 35;\n\nconst int sensPin[] = {16};\nconst int actPin[] = {LED_BUILTIN};\n\n#endif\n</code></pre> <p><code>node_definitions_2.h</code> file:</p> <pre><code>#ifndef NODE_DEFINITIONS_2_H\n#define NODE_DEFINITIONS_2_H\n\n// Node Encryption key\nconst uint8_t key[] = { //\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f\n};\n\n// SPI pinout for TTGO boards\n#define SCK 5\n#define MISO 19\n#define MOSI 27\n\n// LoRa Modem Pinout for TTGO boards\n#define SS 18\n#define RST 14\n#define DIO0 26\n\n// Node Settings\nconst byte nodeID = 0x02;\n\n// Node I/O Pinout\nconst int vbatPin = 35;\n\nconst int sensPin[] = {16};\nconst int actPin[] = {LED_BUILTIN};\n\n#endif\n</code></pre> <p><code>gateway_serial_definitions.h</code> file:</p> <pre><code>#ifndef GATEWAY_SERIAL_DEFINITIONS_H\n#define GATEWAY_SERIAL_DEFINITIONS_H\n\n// Baud rate for serial communication\n#define BAUD_RATE 9600\n\n// LoRa Modem Pinout for boards with the Dragino LoRa shield\n#define SS 10\n#define RST 9\n#define DIO0 2\n\n// Gateway Settings\nconst byte netID = 0xF3;\n\n#endif\n</code></pre> <p>On the <code>comms_protocol.h</code> file the keys arrays should be:</p> <pre><code>// Encryption keys\nconst uint8_t keys[][KEY_SIZE] = {{ //\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x0f\n},{ //\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f\n},\n{ //\n    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x2f\n}};\n</code></pre> <p>After this, the code can be uploaded to both the nodes and the gateway.</p> <p><code>wsn_config.yaml</code> file:</p> <pre><code>wsn_config:\ngateways: \n    - {\n        'serial_port': '/dev/ttyUSB0'\n    }\nnodes:\n    - id: 0x01\n      location: \n          - x: 3\n            y: 1\n      sensors: \n          - id: 0x00\n            name: 'motion sensor'\n            pinMap: [16]\n      actuators: \n          - id: 0x00\n            name: 'BUILTINLED'\n            pinMap: [5]\n\n    - id: 0x02\n      location: \n          - x: 4\n            y: 3\n      sensors: \n          - id: 0x00\n            name: 'motion sensor'\n            pinMap: [16]\n      actuators: \n          - id: 0x00\n            name: 'BUILTINLED'\n            pinMap: [5]\n</code></pre> <p>The Python application is now configured for this network and can be run.</p>"},{"location":"pages/install_guide/","title":"Install Guide","text":""},{"location":"pages/install_guide/#requirements","title":"Requirements","text":"<p>In order to set-up such a wireless sensor network, the following software is required:</p> <ul> <li>Arduino IDE;</li> <li>Python3.</li> </ul> <p>Additionally, the following Arduino libraries are required:</p> <ul> <li>LoRa.h;</li> <li>cppQueue.h;</li> <li>aes256.h.</li> </ul>"},{"location":"pages/install_guide/#clone-the-repository","title":"Clone the repository","text":"<p>After ensuring all the aforementioned requirements are met this repository can be cloned and the contents can be opened in an editor like VScode:</p> <pre><code>git clone https://github.com/cybaer-nova/sensor_network\ncd sensor_network\ncode .\n</code></pre>"},{"location":"pages/install_guide/#configuration","title":"Configuration","text":"<p>The packages now need to be configured according to the hardware available. The network has been tested with both the Arduino Uno platform using the SX1276 Dragino Shield and with the TTGO LoRa ESP32 modules. To this extent, the pin map for the LoRa radio must be configured for all devices:</p> <ul> <li>On the Gateway edit the file <code>gateway_serial_definitions.h</code>;</li> <li>On every Node use the <code>node_definitions</code> folder and create a file for each node. This file is referenced by <code>node_definitions.h</code>.</li> </ul> <p>Additionally, every node needs a unique 32 byte encryption key. This key must also be added to the <code>gateway_serial_definitions.h</code> file. Finally, every node needs a unique hexadecimal ID. The gateway has the encryption keys of all the nodes in an array indexed by the node's ID.</p> <p>Regarding the Network Manager, the <code>wsn_config.yaml</code> file must be edited to include:</p> <ul> <li>The serial port where gateway is attached;</li> <li>Information regarding each node:<ul> <li>ID;</li> <li>Geographic location;</li> <li>Sensors;</li> <li>Actuators;</li> </ul> </li> </ul> <p>It should be noted that example configurations for each file are included in the repository.</p> <p>The last thing to do is to attach any sensors and actuators to the nodes and upload the code. For this, see Example Usage.</p>"},{"location":"pages/repo_structure/","title":"Repository Structure","text":"<p>This repository consists of three packages:</p> <ul> <li>Node: Arduino code for node devices;</li> <li>Gateway: Arduino code for gateway devices;</li> <li>Network Manager: Python application for monitoring, managing and communicating with the network.</li> </ul>"}]}